var tipuesearch = {"pages":[{"title":" gridMCRT ","text":"gridMCRT Brief description License Brief description A Monte Carlo radiation transfer (MCRT) code with voxels representing the geometry, written in modern Fortran.\nThe code is setup to run a MCRT simulation in a sphere, radius 1cm, with isotropic scattering properties and an albedo of 1.\nPhotons are released isotropically from the center of the sphere. The output should give the average number of scatterings as ~57. You can browse the structure of the code using the tabs at the top of the page for more information on how the code is structured.\nThe input file, res/input.params, sets the input parameters of the simulation. Original code was by K. Wood. Current version was heavily modified converted to modern Fortran by L. McMillan. License The gridMCRT source code and related files and documentation are distributed under a permissive free software license (MIT). Developer Info Lewis McMillan, Kenny Wood, Isla Barnard","tags":"home","loc":"index.html"},{"title":"cart_grid – gridMCRT ","text":"type, public :: cart_grid 3D cartesian grid. Stores information about the linear voxel grid Contents Variables delta dim nxg nyg nzg xface yface zface Source Code cart_grid Components Type Visibility Attributes Name Initial real(kind=wp), public :: delta ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls type( vector ), public :: dim half size of grid in each dimension. cm integer, public :: nxg Size of grid in voxels in each direction integer, public :: nyg Size of grid in voxels in each direction integer, public :: nzg Size of grid in voxels in each direction real(kind=wp), public, allocatable :: xface (:) Arrays that store the location of each grid cell(voxel) wall real(kind=wp), public, allocatable :: yface (:) Arrays that store the location of each grid cell(voxel) wall real(kind=wp), public, allocatable :: zface (:) Arrays that store the location of each grid cell(voxel) wall Source Code type :: cart_grid !> Size of grid in voxels in each direction integer :: nxg , nyg , nzg !> half size of grid in each dimension. cm type ( vector ) :: dim !> Arrays that store the location of each grid cell(voxel) wall real ( kind = wp ), allocatable :: xface (:), yface (:), zface (:) !> ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls real ( kind = wp ) :: delta end type cart_grid","tags":"","loc":"type/cart_grid.html"},{"title":"photon – gridMCRT ","text":"type, public :: photon photon type. Encapsulates all information about a single photon. Contents Variables cosp cost dir phi pos sinp sint tflag xcell ycell zcell Type-Bound Procedures scatter Source Code photon Components Type Visibility Attributes Name Initial real(kind=wp), public :: cosp is the azimuthal angle in the physics spherical coordinate system real(kind=wp), public :: cost is the polar angle in the physics spherical coordinate system type( vector ), public :: dir direction vector real(kind=wp), public :: phi is the azimuthal angle in the physics spherical coordinate system type( vector ), public :: pos position vector real(kind=wp), public :: sinp is the azimuthal angle in the physics spherical coordinate system real(kind=wp), public :: sint . is the polar angle in the physics spherical coordinate system logical, public :: tflag Boolean flag that if true photon is alive and in the simulation integer, public :: xcell Current voxel which the photon is in integer, public :: ycell Current voxel which the photon is in integer, public :: zcell Current voxel which the photon is in Type-Bound Procedures procedure, public,  :: scatter public  subroutine scatter (this, opt_prop) photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0)\nadapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html Arguments Type Intent Optional Attributes Name class( photon ) :: this photon packet type( optical_properties ), intent(in) :: opt_prop optical properties Source Code type :: photon !> direction vector type ( vector ) :: dir !> position vector type ( vector ) :: pos !> sin(theta). \\theta is the polar angle in the physics spherical coordinate system real ( kind = wp ) :: sint !> cos(\\theta) \\theta is the polar angle in the physics spherical coordinate system real ( kind = wp ) :: cost !> sin(\\phi) \\phi is the azimuthal angle in the physics spherical coordinate system real ( kind = wp ) :: sinp !> cos(\\phi) \\phi is the azimuthal angle in the physics spherical coordinate system real ( kind = wp ) :: cosp !> \\phi \\phi is the azimuthal angle in the physics spherical coordinate system real ( kind = wp ) :: phi !> Boolean flag that if true photon is alive and in the simulation logical :: tflag !> Current voxel which the photon is in integer :: xcell , ycell , zcell contains procedure :: scatter end type photon","tags":"","loc":"type/photon.html"},{"title":"vector – gridMCRT ","text":"type, public :: vector Vector type used for direction and position vectors\nsupports all possible vector operations Contents Variables x y z Type-Bound Procedures magnitude operator(*) operator(+) operator(-) operator(.dot.) operator(/) print scal_add_vec scal_mult_vec vec_add_scal vec_add_vec vec_div_scal vec_dot vec_minus_vec vec_mult_scal vec_mult_vec Source Code vector Components Type Visibility Attributes Name Initial real(kind=wp), public :: x components of the vector real(kind=wp), public :: y components of the vector real(kind=wp), public :: z components of the vector Type-Bound Procedures procedure, public,  :: magnitude => magnitude_fn get the magnitde of a vector private pure function magnitude_fn (this) implmentation of |vector| Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: this Return Value type( vector ) generic, public,  :: operator(*) => vec_mult_vec , vec_mult_scal , scal_mult_vec multiple a vector by a scalar or vector (element wise) private pure function vec_mult_vec (a, b) implmentation of vector multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) private pure function vec_mult_scal (a, b) implmentation of vector multiply scalar\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) private pure function scal_mult_vec (a, b) implmentation of scalar multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) generic, public,  :: operator(+) => vec_add_vec , vec_add_scal , scal_add_vec add two vectors, or a vector and a scalar private pure function vec_add_vec (a, b) implmentation of vector add vector\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) private pure function vec_add_scal (a, b) implmentation of vector add scalar\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) private pure function scal_add_vec (a, b) implmentation of scalar subtract vector\noverloads the + operator Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) generic, public,  :: operator(-) => vec_minus_vec subtract a vector from a vector private pure function vec_minus_vec (a, b) implmentation of vector subtract vector\noverloads the - operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) generic, public,  :: operator(.dot.) => vec_dot get the dot product of two vectors private pure elemental function vec_dot (a, b) result(dot) implmentation of vector dot vector\ncreates the .dot. operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value real(kind=wp) generic, public,  :: operator(/) => vec_div_scal divide a vector by a float private pure function vec_div_scal (a, b) implmentation of vector divide scalar\noverloads the / operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) procedure, public,  :: print => print_sub print a vector private  subroutine print_sub (this) prints the vector Arguments Type Intent Optional Attributes Name class( vector ) :: this procedure, private, pass(b) :: scal_add_vec private pure function scal_add_vec (a, b) implmentation of scalar subtract vector\noverloads the + operator Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) procedure, private, pass(b) :: scal_mult_vec private pure function scal_mult_vec (a, b) implmentation of scalar multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_add_scal private pure function vec_add_scal (a, b) implmentation of vector add scalar\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_add_vec private pure function vec_add_vec (a, b) implmentation of vector add vector\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_div_scal private pure function vec_div_scal (a, b) implmentation of vector divide scalar\noverloads the / operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_dot private pure elemental function vec_dot (a, b) result(dot) implmentation of vector dot vector\ncreates the .dot. operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value real(kind=wp) procedure, private, pass(a) :: vec_minus_vec private pure function vec_minus_vec (a, b) implmentation of vector subtract vector\noverloads the - operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_mult_scal private pure function vec_mult_scal (a, b) implmentation of vector multiply scalar\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_mult_vec private pure function vec_mult_vec (a, b) implmentation of vector multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) Source Code type :: vector !> components of the vector real ( kind = wp ) :: x , y , z contains !> get the magnitde of a vector procedure :: magnitude => magnitude_fn !> print a vector procedure :: print => print_sub !> get the dot product of two vectors generic :: operator (. dot .) => vec_dot !> divide a vector by a float generic :: operator ( / ) => vec_div_scal !> multiple a vector by a scalar or vector (element wise) generic :: operator ( * ) => vec_mult_vec , vec_mult_scal , scal_mult_vec !> add two vectors, or a vector and a scalar generic :: operator ( + ) => vec_add_vec , vec_add_scal , scal_add_vec !> subtract a vector from a vector generic :: operator ( - ) => vec_minus_vec procedure , pass ( a ), private :: vec_dot procedure , pass ( a ), private :: vec_div_scal procedure , pass ( a ), private :: vec_mult_vec procedure , pass ( a ), private :: vec_mult_scal procedure , pass ( b ), private :: scal_mult_vec procedure , pass ( a ), private :: vec_add_vec procedure , pass ( a ), private :: vec_add_scal procedure , pass ( b ), private :: scal_add_vec procedure , pass ( a ), private :: vec_minus_vec end type vector","tags":"","loc":"type/vector.html"},{"title":"optical_properties – gridMCRT ","text":"type, public :: optical_properties Stores the optical properties of the medium. Currently only 1 media type. Can expand by making these arrays. Contents Variables albedo g2 hgg kappa mua mus Source Code optical_properties Components Type Visibility Attributes Name Initial real(kind=wp), public :: albedo The albedo is real(kind=wp), public :: g2 Is the g factor squared real(kind=wp), public :: hgg hgg is the g factor. Describes the bias of the scattering direction. 1 means forward, 0 isotropic and -1 backscattering. unitless real(kind=wp), public :: kappa is + real(kind=wp), public :: mua is the absorption coefficent. in cm real(kind=wp), public :: mus is the scattering coefficent. in cm Source Code type :: optical_properties !> \\mu_s is the scattering coefficent. in cm&#94;{-1} real ( kind = wp ) :: mus !> \\mu_a is the absorption coefficent. in cm&#94;{-1} real ( kind = wp ) :: mua !> hgg is the g factor. Describes the bias of the scattering direction. 1 means forward, 0 isotropic and -1 backscattering. unitless real ( kind = wp ) :: hgg !> Is the g factor squared real ( kind = wp ) :: g2 !> \\kappa is \\mu_s + \\mu_a real ( kind = wp ) :: kappa !> The albedo is \\frac{\\mu_s}{\\mu_a+\\mu_s} real ( kind = wp ) :: albedo end type optical_properties","tags":"","loc":"type/optical_properties.html"},{"title":"alloc_array – gridMCRT","text":"private  subroutine alloc_array(grid) Uses iarray allocates allocatable 3D arrays Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(inout) :: grid Contents Source Code alloc_array Source Code subroutine alloc_array ( grid ) !!  allocates allocatable 3D arrays use iarray , only : rhokap type ( cart_grid ), intent ( inout ) :: grid allocate ( rhokap ( grid % nxg , grid % nyg , grid % nzg )) allocate ( grid % xface ( grid % nxg + 1 )) allocate ( grid % yface ( grid % nyg + 1 )) allocate ( grid % zface ( grid % nzg + 1 )) end subroutine alloc_array","tags":"","loc":"proc/alloc_array.html"},{"title":"gridset – gridMCRT","text":"public  subroutine gridset(grid, opt_prop, nxg, nyg, nzg, xmax, ymax, zmax) Uses iarray optical_properties_class Set up grids and create geometry Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(out) :: grid grid variable that is assigned in this routine type( optical_properties ), intent(in) :: opt_prop optical properties used to setup voxel geometry integer, intent(in) :: nxg number of voxels in each dimension integer, intent(in) :: nyg number of voxels in each dimension integer, intent(in) :: nzg number of voxels in each dimension real(kind=wp), intent(in) :: xmax half size of the grid in cm real(kind=wp), intent(in) :: ymax half size of the grid in cm real(kind=wp), intent(in) :: zmax half size of the grid in cm Contents Source Code gridset Source Code subroutine gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) !! Set up grids and create geometry use iarray , only : rhokap , rhokap use optical_properties_class , only : optical_properties !> grid variable that is assigned in this routine type ( cart_grid ), intent ( out ) :: grid !> optical properties used to setup voxel geometry type ( optical_properties ), intent ( in ) :: opt_prop !> number of voxels in each dimension integer , intent ( in ) :: nxg , nyg , nzg !> half size of the grid in cm real ( kind = wp ), intent ( in ) :: xmax , ymax , zmax !> loop variables integer :: i , j , k !> temp variables real ( kind = wp ) :: x , y , z , taueq1 , taupole1 , taueq2 , taupole2 print * , ' ' print * , 'Setting up grid....' ! set grid dimensions and voxel numbers grid % dim = vector ( xmax , ymax , zmax ) grid % nxg = nxg grid % nyg = nyg grid % nzg = nzg ! Set small distance for use in optical depth integration routines ! for roundoff effects when crossing cell walls grid % delta = 1.e-8_wp * ( 2._wp * grid % dim % z / grid % nzg ) ! allocate and set arrays to 0 call alloc_array ( grid ) call zarray ( grid ) ! setup grid cell walls do i = 1 , grid % nxg + 1 grid % xface ( i ) = ( i - 1 ) * 2._wp * grid % dim % x / grid % nxg end do do i = 1 , grid % nyg + 1 grid % yface ( i ) = ( i - 1 ) * 2._wp * grid % dim % y / grid % nyg end do do i = 1 , grid % nzg + 1 grid % zface ( i ) = ( i - 1 ) * 2._wp * grid % dim % z / grid % nzg end do !set up optical properties grid do i = 1 , grid % nxg x = grid % xface ( i ) - grid % dim % x + grid % dim % x / grid % nxg do j = 1 , grid % nyg y = grid % yface ( j ) - grid % dim % y + grid % dim % y / grid % nyg do k = 1 , grid % nzg z = grid % zface ( k ) - grid % dim % z + grid % dim % z / grid % nzg ! create a sphere of radius 1. if ( sqrt ( x ** 2 + y ** 2 + z ** 2 ) <= 1._wp ) then rhokap ( i , j , k ) = opt_prop % kappa else rhokap ( i , j , k ) = 0._wp end if end do end do end do ! Calculate equatorial and polar optical depths ! useful for debugging geometry taueq1 = 0._wp taupole1 = 0._wp taueq2 = 0._wp taupole2 = 0._wp do i = 1 , grid % nxg taueq1 = taueq1 + rhokap ( i , grid % nyg / 2 , grid % nzg / 2 ) end do do i = 1 , grid % nzg taupole1 = taupole1 + rhokap ( grid % nxg / 2 , grid % nyg / 2 , i ) end do taueq1 = taueq1 * 2._wp * grid % dim % x / grid % nxg taupole1 = taupole1 * 2._wp * grid % dim % z / grid % nzg print '(A,F9.5,A,F9.5)' , ' taueq1 = ' , taueq1 , '  taupole1 = ' , taupole1 end subroutine gridset","tags":"","loc":"proc/gridset.html"},{"title":"zarray – gridMCRT","text":"private  subroutine zarray(grid) Uses iarray set all 3D arrays to zero Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(inout) :: grid Contents Source Code zarray Source Code subroutine zarray ( grid ) !! set all 3D arrays to zero use iarray , only : rhokap type ( cart_grid ), intent ( inout ) :: grid rhokap = 0._wp grid % xface = 0._wp grid % yface = 0._wp grid % zface = 0._wp end subroutine zarray","tags":"","loc":"proc/zarray.html"},{"title":"ran2 – gridMCRT","text":"public  function ran2() Wrapper function to fortran internal random number generator\nGenerates a random number in the range [0,1.) Arguments None Return Value real(kind=wp) Contents None","tags":"","loc":"proc/ran2.html"},{"title":"ranu – gridMCRT","text":"public  function ranu(a, b) sample uniformly between [a, b] Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a input lower bound real(kind=wp), intent(in) :: b input upper bound Return Value real(kind=wp) Contents","tags":"","loc":"proc/ranu.html"},{"title":"init_seed – gridMCRT","text":"public  subroutine init_seed(seed) user convenience function for setting random generator seed Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed user defined seed Contents Source Code init_seed Source Code subroutine init_seed ( seed ) !! user convenience function for setting random generator seed !> user defined seed integer , intent ( in ) :: seed !> size of internal seed array integer :: n !> internal seed array to be filled with user defined seed integer , allocatable :: iseed (:) ! get seed size call random_seed ( size = n ) allocate ( iseed ( n )) ! put user seed in actual seed iseed = seed ! seed the RNG call random_seed ( put = iseed ) end subroutine init_seed","tags":"","loc":"proc/init_seed.html"},{"title":"isotropic_point_src – gridMCRT","text":"public  subroutine isotropic_point_src(packet, grid) Uses gridset_mod constants photon_class random_mod set intial photon position at (0.0, 0.0, 0.0) and sample photon direction in an isotropic manner. Arguments Type Intent Optional Attributes Name type( photon ), intent(out) :: packet photon object type( cart_grid ), intent(in) :: grid grid object Contents Source Code isotropic_point_src Source Code subroutine isotropic_point_src ( packet , grid ) !! set intial photon position at (0.0, 0.0, 0.0) and sample photon direction in an isotropic manner. use constants , only : TWOPI , wp use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 !> photon object type ( photon ), intent ( out ) :: packet !> grid object type ( cart_grid ), intent ( in ) :: grid !set packet position packet % pos % z = 0.0_wp packet % pos % x = 0.0_wp packet % pos % y = 0.0_wp ! set packet cosines packet % phi = ran2 () * twoPI packet % cosp = cos ( packet % phi ) packet % sinp = sin ( packet % phi ) packet % cost = 2._wp * ran2 () - 1._wp packet % sint = sqrt ( 1._wp - packet % cost ** 2 ) ! set direction vector packet % dir % x = packet % sint * packet % cosp packet % dir % y = packet % sint * packet % sinp packet % dir % z = packet % cost ! set packet voxel packet % xcell = int ( grid % nxg * ( packet % pos % x + grid % dim % x ) / ( 2._wp * grid % dim % x )) + 1 packet % ycell = int ( grid % nyg * ( packet % pos % y + grid % dim % y ) / ( 2._wp * grid % dim % y )) + 1 packet % zcell = int ( grid % nzg * ( packet % pos % z + grid % dim % z ) / ( 2._wp * grid % dim % z )) + 1 packet % tflag = . false . end subroutine isotropic_point_src","tags":"","loc":"proc/isotropic_point_src.html"},{"title":"writer – gridMCRT","text":"public  subroutine writer(grid, nphotons) Uses gridset_mod constants subroutine to write out normalised fluence Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(in) :: grid grid integer, intent(in) :: nphotons number of photons to normalise by Contents Source Code writer Source Code subroutine writer ( grid , nphotons ) !! subroutine to write out normalised fluence use constants , only : fileplace use gridset_mod , only : cart_grid !> grid type ( cart_grid ), intent ( in ) :: grid !> number of photons to normalise by integer , intent ( in ) :: nphotons ! normalise fluence assuming power is 1W ! write out fluence end subroutine writer","tags":"","loc":"proc/writer.html"},{"title":"wall_dist – gridMCRT","text":"private  function wall_dist(packet, grid, celli, cellj, cellk, pos, dir) Uses gridset_mod vector_class photon_class function that returns distant to nearest wall and which wall that is (x ,y or z) Arguments Type Intent Optional Attributes Name type( photon ), intent(inout) :: packet photon packet type( cart_grid ), intent(in) :: grid grid variable container integer, intent(inout) :: celli current voxel ID integer, intent(inout) :: cellj current voxel ID integer, intent(inout) :: cellk current voxel ID type( vector ), intent(inout) :: pos current position logical, intent(inout) :: dir (:) which wall will we hit. Stored as array of bools Return Value real(kind=wp) Contents","tags":"","loc":"proc/wall_dist.html"},{"title":"tauint1 – gridMCRT","text":"public  subroutine tauint1(packet, grid) Uses iarray vector_class photon_class gridset_mod random_mod optical depth integration subroutine. The main workhorse of MCRT Arguments Type Intent Optional Attributes Name type( photon ), intent(inout) :: packet packet to move through the grid type( cart_grid ), intent(in) :: grid grid that the packet moves through Contents Source Code tauint1 Source Code subroutine tauint1 ( packet , grid ) !! optical depth integration subroutine. The main workhorse of MCRT use gridset_mod , only : cart_grid use iarray , only : rhokap use photon_class , only : photon use random_mod , only : ran2 use vector_class , only : vector !> packet to move through the grid type ( photon ), intent ( inout ) :: packet !> grid that the packet moves through type ( cart_grid ), intent ( in ) :: grid ! intermediate position type ( vector ) :: pos real ( kind = wp ) :: tau , taurun , taucell , d , dcell integer :: celli , cellj , cellk logical :: dir ( 3 ) !change grid origin to lower left of the grid pos = packet % pos + grid % dim ! store current voxel in temp variables celli = packet % xcell cellj = packet % ycell cellk = packet % zcell ! setup to start integrating taurun = 0._wp d = 0._wp dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !sample optical distance tau = - log ( ran2 ()) do dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !get distance to nearest wall in direction dir dcell = wall_dist ( packet , grid , celli , cellj , cellk , pos , dir ) !calculate optical distnace to cell wall taucell = dcell * rhokap ( celli , cellj , cellk ) if ( taurun + taucell < tau ) then !still some tau to move taurun = taurun + taucell d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . TRUE ., dir ) else !moved full distance dcell = ( tau - taurun ) / rhokap ( celli , cellj , cellk ) d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . FALSE ., dir ) exit end if if ( celli == - 1 . or . cellj == - 1 . or . cellk == - 1 ) then packet % tflag = . true . exit end if end do ! move back to grid with origin at the centre packet % pos = pos - grid % dim packet % xcell = celli packet % ycell = cellj packet % zcell = cellk end subroutine tauint1","tags":"","loc":"proc/tauint1.html"},{"title":"update_pos – gridMCRT","text":"private  subroutine update_pos(packet, grid, pos, celli, cellj, cellk, dcell, wall_flag, dir) Uses utils vector_class photon_class gridset_mod random_mod routine that upates postions of photon and calls fresnel routines if photon leaves current voxel Arguments Type Intent Optional Attributes Name type( photon ), intent(in) :: packet photon object type( cart_grid ), intent(in) :: grid grid object type( vector ), intent(inout) :: pos current photon position integer, intent(inout) :: celli current voxel ID integer, intent(inout) :: cellj current voxel ID integer, intent(inout) :: cellk current voxel ID real(kind=wp), intent(in) :: dcell distance phton will travel across a cell logical, intent(in) :: wall_flag flag is true if we hit a cell wall logical, intent(in) :: dir (:) logical array. 1 entry is always true. the true entry represents which cell wall we will hit Contents Source Code update_pos Source Code subroutine update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , wall_flag , dir ) !! routine that upates postions of photon and calls fresnel routines if photon leaves current voxel use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 use utils , only : str use vector_class , only : vector !> photon object type ( photon ), intent ( in ) :: packet !> current photon position type ( vector ), intent ( inout ) :: pos !> grid object type ( cart_grid ), intent ( in ) :: grid !> distance phton will travel across a cell real ( kind = wp ), intent ( in ) :: dcell !> current voxel ID integer , intent ( inout ) :: celli , cellj , cellk !> flag is true if we hit a cell wall logical , intent ( in ) :: wall_flag !> logical array. 1 entry is always true. the true entry represents which cell wall we will hit logical , intent ( in ) :: dir (:) ! if we hit a wall if ( wall_flag ) then ! in the x direction if ( dir ( 1 )) then if ( packet % dir % x > 0._wp ) then pos % x = grid % xface ( celli + 1 ) + grid % delta celli = celli + 1 elseif ( packet % dir % x < 0._wp ) then pos % x = grid % xface ( celli ) - grid % delta celli = celli - 1 else error stop 'Error in x dir in update_pos' end if pos % y = pos % y + packet % dir % y * dcell pos % z = pos % z + packet % dir % z * dcell ! y direction elseif ( dir ( 2 )) then if ( packet % dir % y > 0._wp ) then pos % y = grid % yface ( cellj + 1 ) + grid % delta cellj = cellj + 1 elseif ( packet % dir % y < 0._wp ) then pos % y = grid % yface ( cellj ) - grid % delta cellj = cellj - 1 else error stop 'Error in y dir in update_pos' end if pos % x = pos % x + packet % dir % x * dcell pos % z = pos % z + packet % dir % z * dcell ! z direction elseif ( dir ( 3 )) then if ( packet % dir % z > 0._wp ) then pos % z = grid % zface ( cellk + 1 ) + grid % delta cellk = cellk + 1 elseif ( packet % dir % z < 0._wp ) then pos % z = grid % zface ( cellk ) - grid % delta cellk = cellk - 1 else error stop 'Error in z dir in update_pos' end if pos % x = pos % x + packet % dir % x * dcell pos % y = pos % y + packet % dir % y * dcell else error stop 'Error in update_pos...' end if else ! we dont hit a wall pos = pos + packet % dir * dcell end if if ( wall_flag ) then ! if we hit a wall, get current voxel call update_voxels ( pos , grid , celli , cellj , cellk ) end if end subroutine update_pos","tags":"","loc":"proc/update_pos.html"},{"title":"update_voxels – gridMCRT","text":"private pure subroutine update_voxels(pos, grid, celli, cellj, cellk) Uses gridset_mod vector_class updates the current voxel based upon position Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: pos current photon position vector type( cart_grid ), intent(in) :: grid grid object integer, intent(inout) :: celli current voxel ID. To be updated integer, intent(inout) :: cellj current voxel ID. To be updated integer, intent(inout) :: cellk current voxel ID. To be updated Contents Source Code update_voxels Source Code pure subroutine update_voxels ( pos , grid , celli , cellj , cellk ) !! updates the current voxel based upon position use gridset_mod , only : cart_grid use vector_class , only : vector !> current photon position vector type ( vector ), intent ( in ) :: pos !> grid object type ( cart_grid ), intent ( in ) :: grid !> current voxel ID. To be updated integer , intent ( inout ) :: celli , cellj , cellk celli = floor ( grid % nxg * ( pos % x ) / ( 2._wp * grid % dim % x )) + 1 cellj = floor ( grid % nyg * ( pos % y ) / ( 2._wp * grid % dim % y )) + 1 cellk = floor ( grid % nzg * ( pos % z ) / ( 2._wp * grid % dim % z )) + 1 if ( celli > grid % nxg . or . celli < 1 ) celli = - 1 if ( cellj > grid % nyg . or . cellj < 1 ) cellj = - 1 if ( cellk > grid % nzg . or . cellk < 1 ) cellk = - 1 end subroutine update_voxels","tags":"","loc":"proc/update_voxels.html"},{"title":"scatter – gridMCRT","text":"public  subroutine scatter(this, opt_prop) Uses optical_properties_class constants random_mod photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0)\nadapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html Type Bound photon Arguments Type Intent Optional Attributes Name class( photon ) :: this photon packet type( optical_properties ), intent(in) :: opt_prop optical properties Contents Source Code scatter Source Code subroutine scatter ( this , opt_prop ) !! photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0) !! adapted from mcxyz [https://omlc.org/software/mc/mcxyz/index.html](https://omlc.org/software/mc/mcxyz/index.html) use optical_properties_class , only : optical_properties use constants , only : PI , TWOPI use random_mod , only : ran2 !> photon packet class ( photon ) :: this !> optical properties type ( optical_properties ), intent ( in ) :: opt_prop real ( kind = wp ) :: temp , uxx , uyy , uzz if ( opt_prop % hgg == 0.0_wp ) then !isotropic scattering this % cost = 2._wp * ran2 () - 1._wp else !henyey-greenstein scattering temp = ( 1.0_wp - opt_prop % g2 ) / ( 1.0_wp - opt_prop % hgg + 2._wp * opt_prop % hgg * ran2 ()) this % cost = ( 1.0_wp + opt_prop % g2 - temp ** 2 ) / ( 2._wp * opt_prop % hgg ) end if this % sint = sqrt ( 1._wp - this % cost ** 2 ) this % phi = TWOPI * ran2 () this % cosp = cos ( this % phi ) if ( this % phi < PI ) then this % sinp = sqrt ( 1._wp - this % cosp ** 2 ) else this % sinp = - sqrt ( 1._wp - this % cosp ** 2 ) end if if ( 1._wp - abs ( this % dir % z ) <= 1e-12_wp ) then ! near perpindicular uxx = this % sint * this % cosp uyy = this % sint * this % sinp uzz = sign ( this % cost , this % dir % z ) else temp = sqrt ( 1._wp - this % dir % z ** 2 ) uxx = this % sint * ( this % dir % x * this % dir % z * this % cosp - this % dir % y * this % sinp ) & / temp + this % dir % x * this % cost uyy = this % sint * ( this % dir % y * this % dir % z * this % cosp + this % dir % x * this % sinp ) & / temp + this % dir % y * this % cost uzz = - 1. * this % sint * this % cosp * temp + this % dir % z * this % cost end if this % dir % x = uxx this % dir % y = uyy this % dir % z = uzz end subroutine scatter","tags":"","loc":"proc/scatter.html"},{"title":"magnitude_fn – gridMCRT","text":"private pure function magnitude_fn(this) implmentation of |vector| Type Bound vector Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: this Return Value type( vector ) Contents Source Code magnitude_fn Source Code pure type ( vector ) function magnitude_fn ( this ) !! implmentation of |vector| class ( vector ), intent ( in ) :: this real ( kind = wp ) :: tmp tmp = sqrt ( this % x ** 2 + this % y ** 2 + this % z ** 2 ) magnitude_fn = this / tmp end function magnitude_fn","tags":"","loc":"proc/magnitude_fn.html"},{"title":"scal_add_vec – gridMCRT","text":"private pure function scal_add_vec(a, b) implmentation of scalar subtract vector\noverloads the + operator Type Bound vector Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) Contents Source Code scal_add_vec Source Code pure type ( vector ) function scal_add_vec ( a , b ) !! implmentation of scalar subtract vector !! overloads the + operator class ( vector ), intent ( IN ) :: b real ( kind = wp ), intent ( IN ) :: a scal_add_vec = vector ( b % x + a , b % y + a , b % z + a ) end function scal_add_vec","tags":"","loc":"proc/scal_add_vec.html"},{"title":"scal_mult_vec – gridMCRT","text":"private pure function scal_mult_vec(a, b) implmentation of scalar multiply vector\noverloads the * operator Type Bound vector Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) Contents Source Code scal_mult_vec Source Code pure type ( vector ) function scal_mult_vec ( a , b ) !! implmentation of scalar multiply vector !! overloads the * operator class ( vector ), intent ( IN ) :: b real ( kind = wp ), intent ( IN ) :: a scal_mult_vec = vector ( a * b % x , a * b % y , a * b % z ) end function scal_mult_vec","tags":"","loc":"proc/scal_mult_vec.html"},{"title":"vec_add_scal – gridMCRT","text":"private pure function vec_add_scal(a, b) implmentation of vector add scalar\noverloads the + operator Type Bound vector Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) Contents Source Code vec_add_scal Source Code pure type ( vector ) function vec_add_scal ( a , b ) !! implmentation of vector add scalar !! overloads the + operator class ( vector ), intent ( IN ) :: a real ( kind = wp ), intent ( IN ) :: b vec_add_scal = vector ( a % x + b , a % y + b , a % z + b ) end function vec_add_scal","tags":"","loc":"proc/vec_add_scal.html"},{"title":"vec_add_vec – gridMCRT","text":"private pure function vec_add_vec(a, b) implmentation of vector add vector\noverloads the + operator Type Bound vector Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) Contents Source Code vec_add_vec Source Code pure type ( vector ) function vec_add_vec ( a , b ) !! implmentation of vector add vector !! overloads the + operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_add_vec = vector ( a % x + b % x , a % y + b % y , a % z + b % z ) end function vec_add_vec","tags":"","loc":"proc/vec_add_vec.html"},{"title":"vec_div_scal – gridMCRT","text":"private pure function vec_div_scal(a, b) implmentation of vector divide scalar\noverloads the / operator Type Bound vector Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) Contents Source Code vec_div_scal Source Code pure type ( vector ) function vec_div_scal ( a , b ) !! implmentation of vector divide scalar !! overloads the / operator class ( vector ), intent ( IN ) :: a real ( kind = wp ), intent ( IN ) :: b vec_div_scal = vector ( a % x / b , a % y / b , a % z / b ) end function vec_div_scal","tags":"","loc":"proc/vec_div_scal.html"},{"title":"vec_dot – gridMCRT","text":"private pure elemental function vec_dot(a, b) result(dot) implmentation of vector dot vector\ncreates the .dot. operator Type Bound vector Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value real(kind=wp) Contents Source Code vec_dot Source Code pure elemental function vec_dot ( a , b ) result ( dot ) !! implmentation of vector dot vector !! creates the .dot. operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b real ( kind = wp ) :: dot dot = ( a % x * b % x ) + ( a % y * b % y ) + ( a % z * b % z ) end function vec_dot","tags":"","loc":"proc/vec_dot.html"},{"title":"vec_minus_vec – gridMCRT","text":"private pure function vec_minus_vec(a, b) implmentation of vector subtract vector\noverloads the - operator Type Bound vector Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) Contents Source Code vec_minus_vec Source Code pure type ( vector ) function vec_minus_vec ( a , b ) !! implmentation of vector subtract vector !! overloads the - operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_minus_vec = vector ( a % x - b % x , a % y - b % y , a % z - b % z ) end function vec_minus_vec","tags":"","loc":"proc/vec_minus_vec.html"},{"title":"vec_mult_scal – gridMCRT","text":"private pure function vec_mult_scal(a, b) implmentation of vector multiply scalar\noverloads the * operator Type Bound vector Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) Contents Source Code vec_mult_scal Source Code pure type ( vector ) function vec_mult_scal ( a , b ) !! implmentation of vector multiply scalar !! overloads the * operator class ( vector ), intent ( IN ) :: a real ( kind = wp ), intent ( IN ) :: b vec_mult_scal = vector ( a % x * b , a % y * b , a % z * b ) end function vec_mult_scal","tags":"","loc":"proc/vec_mult_scal.html"},{"title":"vec_mult_vec – gridMCRT","text":"private pure function vec_mult_vec(a, b) implmentation of vector multiply vector\noverloads the * operator Type Bound vector Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) Contents Source Code vec_mult_vec Source Code pure type ( vector ) function vec_mult_vec ( a , b ) !! implmentation of vector multiply vector !! overloads the * operator !@note !    This is ELEMENT wise multiplication !@end note class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_mult_vec = vector ( a % x * b % x , a % y * b % y , a % z * b % z ) end function vec_mult_vec","tags":"","loc":"proc/vec_mult_vec.html"},{"title":"print_sub – gridMCRT","text":"private  subroutine print_sub(this) prints the vector Type Bound vector Arguments Type Intent Optional Attributes Name class( vector ) :: this Contents Source Code print_sub Source Code subroutine print_sub ( this ) !! prints the vector class ( vector ) :: this print * , this % x , this % y , this % z end subroutine print_sub","tags":"","loc":"proc/print_sub.html"},{"title":"init_opt2 – gridMCRT","text":"public  subroutine init_opt2(opt_prop) Set tissue optical properties 420nm Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop optical property container Contents Source Code init_opt2 Source Code subroutine init_opt2 ( opt_prop ) !!  Set tissue optical properties 420nm !> optical property container type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.9_wp opt_prop % g2 = opt_prop % hgg ** 2._wp opt_prop % mua = 1.8_wp opt_prop % mus = 8 2.0_wp / ( 1.0_wp - opt_prop % hgg ) opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt2","tags":"","loc":"proc/init_opt2.html"},{"title":"init_opt_sphere – gridMCRT","text":"public  subroutine init_opt_sphere(opt_prop) Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop optical property container Contents Source Code init_opt_sphere Source Code subroutine init_opt_sphere ( opt_prop ) !!  Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. !> optical property container type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.0_wp opt_prop % g2 = opt_prop % hgg ** 2._wp opt_prop % mua = 0.0_wp opt_prop % mus = 1 0.0_wp opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt_sphere","tags":"","loc":"proc/init_opt_sphere.html"},{"title":"str_I32 – gridMCRT","text":"private  function str_I32(i) Uses iso_fortran_env convert an int32 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable Contents Source Code str_I32 Source Code function str_I32 ( i ) !! convert an int32 integer into a string use iso_fortran_env , only : Int32 !> input int to convert into string integer ( int32 ), intent ( IN ) :: i character ( len = :), allocatable :: str_I32 character ( len = 100 ) :: string write ( string , '(I100.1)' ) I str_I32 = trim ( adjustl ( string )) end function str_I32","tags":"","loc":"proc/str_i32.html"},{"title":"str_I64 – gridMCRT","text":"private  function str_I64(i) Uses iso_fortran_env convert an int64 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable Contents Source Code str_I64 Source Code function str_I64 ( i ) !! convert an int64 integer into a string use iso_fortran_env , only : Int64 !> input int to convert into string integer ( Int64 ), intent ( IN ) :: i character ( len = :), allocatable :: str_I64 character ( len = 100 ) :: string write ( string , '(I100.1)' ) I str_I64 = trim ( adjustl ( string )) end function str_I64","tags":"","loc":"proc/str_i64.html"},{"title":"str_R8 – gridMCRT","text":"private  function str_R8(i) convert an double precision float into a string Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: i input float to convert into string Return Value character(len=:), allocatable Contents Source Code str_R8 Source Code function str_R8 ( i ) !! convert an double precision float into a string !> input float to convert into string real ( kind = wp ), intent ( IN ) :: i character ( len = :), allocatable :: str_R8 character ( len = 100 ) :: string write ( string , '(f100.16)' ) I str_R8 = trim ( adjustl ( string )) end function str_r8","tags":"","loc":"proc/str_r8.html"},{"title":"str_R8array – gridMCRT","text":"private  function str_R8array(a) convert an double precision float array into a string Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:) input float array to convert into string Return Value character(len=:), allocatable Contents Source Code str_R8array Source Code function str_R8array ( a ) !! convert an double precision float array into a string !> input float array to convert into string real ( kind = wp ), intent ( IN ) :: a (:) character ( len = :), allocatable :: str_R8array character ( len = 100 ) :: string integer :: i do i = 1 , size ( a ) write ( string , '(f100.16)' ) a ( i ) str_R8array = str_R8array // ' ' // trim ( adjustl ( string )) end do end function str_R8array","tags":"","loc":"proc/str_r8array.html"},{"title":"str_iarray – gridMCRT","text":"private  function str_iarray(i) convert an int32 integer array into a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) input int array to convert into string Return Value character(len=:), allocatable Contents Source Code str_iarray Source Code function str_iarray ( i ) !! convert an int32 integer array into a string !> input int array to convert into string integer , intent ( IN ) :: i (:) character ( len = :), allocatable :: str_iarray character ( len = 100 ) :: string integer :: j do j = 1 , size ( i ) write ( string , '(I100.1)' ) I ( j ) str_iarray = str_iarray // ' ' // trim ( adjustl ( string )) end do end function str_iarray","tags":"","loc":"proc/str_iarray.html"},{"title":"str_logicalarray – gridMCRT","text":"private  function str_logicalarray(a) convert an logical array into a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: a (:) input logical array to convert into string Return Value character(len=:), allocatable Contents Source Code str_logicalarray Source Code function str_logicalarray ( a ) !! convert an logical array into a string !> input logical array to convert into string logical , intent ( IN ) :: a (:) character ( len = :), allocatable :: str_logicalarray character ( len = 100 ) :: string integer :: i do i = 1 , size ( a ) write ( string , '(L1)' ) a ( i ) str_logicalarray = str_logicalarray // ' ' // trim ( adjustl ( string )) end do end function str_logicalarray","tags":"","loc":"proc/str_logicalarray.html"},{"title":"set_directories – gridMCRT","text":"public  subroutine set_directories() Uses constants define variables to hold paths to various folders Arguments None Contents Source Code set_directories Source Code subroutine set_directories () !! define variables to hold paths to various folders use constants , only : homedir , fileplace , resdir character ( len = 255 ) :: cwd !get current working directory call get_environment_variable ( 'PWD' , cwd ) ! get 'home' dir from cwd if ( index ( cwd , \"bin\" ) > 0 ) then ! if program is run from bin dir homedir = trim ( cwd ( 1 : len ( trim ( cwd )) - 3 )) else ! program is run from root dir homedir = trim ( cwd ) // \"/\" end if ! get data dir fileplace = trim ( homedir ) // 'data/' ! get res dir resdir = trim ( homedir ) // 'res/' end subroutine set_directories","tags":"","loc":"proc/set_directories.html"},{"title":"str – gridMCRT","text":"public interface str functions to turn numerical variables into strings Contents Module Procedures str_I32 str_I64 str_Iarray str_R8 str_R8array str_logicalarray Module Procedures private  function str_I32 (i) convert an int32 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_I64 (i) convert an int64 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_iarray (i) convert an int32 integer array into a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) input int array to convert into string Return Value character(len=:), allocatable private  function str_R8 (i) convert an double precision float into a string Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: i input float to convert into string Return Value character(len=:), allocatable private  function str_R8array (a) convert an double precision float array into a string Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:) input float array to convert into string Return Value character(len=:), allocatable private  function str_logicalarray (a) convert an logical array into a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: a (:) input logical array to convert into string Return Value character(len=:), allocatable","tags":"","loc":"interface/str.html"},{"title":"gridset_mod – gridMCRT","text":"Module provides a cartesian grid type to store all grid related variables in a container\nAlso provides a way of setting up the geomerty/grid for the simulation. Uses vector_class constants Contents Derived Types cart_grid Subroutines alloc_array gridset zarray Derived Types type, public :: cart_grid 3D cartesian grid. Stores information about the linear voxel grid Components Type Visibility Attributes Name Initial real(kind=wp), public :: delta ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls type( vector ), public :: dim half size of grid in each dimension. cm integer, public :: nxg Size of grid in voxels in each direction integer, public :: nyg Size of grid in voxels in each direction integer, public :: nzg Size of grid in voxels in each direction real(kind=wp), public, allocatable :: xface (:) Arrays that store the location of each grid cell(voxel) wall real(kind=wp), public, allocatable :: yface (:) Arrays that store the location of each grid cell(voxel) wall real(kind=wp), public, allocatable :: zface (:) Arrays that store the location of each grid cell(voxel) wall Subroutines private  subroutine alloc_array (grid) allocates allocatable 3D arrays Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(inout) :: grid public  subroutine gridset (grid, opt_prop, nxg, nyg, nzg, xmax, ymax, zmax) Set up grids and create geometry Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(out) :: grid grid variable that is assigned in this routine type( optical_properties ), intent(in) :: opt_prop optical properties used to setup voxel geometry integer, intent(in) :: nxg number of voxels in each dimension integer, intent(in) :: nyg number of voxels in each dimension integer, intent(in) :: nzg number of voxels in each dimension real(kind=wp), intent(in) :: xmax half size of the grid in cm real(kind=wp), intent(in) :: ymax half size of the grid in cm real(kind=wp), intent(in) :: zmax half size of the grid in cm private  subroutine zarray (grid) set all 3D arrays to zero Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(inout) :: grid","tags":"","loc":"module/gridset_mod.html"},{"title":"random_mod – gridMCRT","text":"module containg routines related to random numbers Uses constants Contents Functions ran2 ranu Subroutines init_seed Functions public  function ran2 () Wrapper function to fortran internal random number generator\nGenerates a random number in the range [0,1.) Arguments None Return Value real(kind=wp) public  function ranu (a, b) sample uniformly between [a, b] Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a input lower bound real(kind=wp), intent(in) :: b input upper bound Return Value real(kind=wp) Subroutines public  subroutine init_seed (seed) user convenience function for setting random generator seed Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed user defined seed","tags":"","loc":"module/random_mod.html"},{"title":"sourceph_mod – gridMCRT","text":"Module contains the routines to inialise a photon, i.e different light sources. Contents Subroutines isotropic_point_src Subroutines public  subroutine isotropic_point_src (packet, grid) set intial photon position at (0.0, 0.0, 0.0) and sample photon direction in an isotropic manner. Arguments Type Intent Optional Attributes Name type( photon ), intent(out) :: packet photon object type( cart_grid ), intent(in) :: grid grid object","tags":"","loc":"module/sourceph_mod.html"},{"title":"writer_mod – gridMCRT","text":"I/O related routines. Contents Subroutines writer Subroutines public  subroutine writer (grid, nphotons) subroutine to write out normalised fluence Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(in) :: grid grid integer, intent(in) :: nphotons number of photons to normalise by","tags":"","loc":"module/writer_mod.html"},{"title":"inttau2 – gridMCRT","text":"module contains routines related to the optical depth integration of a photon though a 3D grid. Uses constants Contents Functions wall_dist Subroutines tauint1 update_pos update_voxels Functions private  function wall_dist (packet, grid, celli, cellj, cellk, pos, dir) function that returns distant to nearest wall and which wall that is (x ,y or z) Arguments Type Intent Optional Attributes Name type( photon ), intent(inout) :: packet photon packet type( cart_grid ), intent(in) :: grid grid variable container integer, intent(inout) :: celli current voxel ID integer, intent(inout) :: cellj current voxel ID integer, intent(inout) :: cellk current voxel ID type( vector ), intent(inout) :: pos current position logical, intent(inout) :: dir (:) which wall will we hit. Stored as array of bools Return Value real(kind=wp) Subroutines public  subroutine tauint1 (packet, grid) optical depth integration subroutine. The main workhorse of MCRT Arguments Type Intent Optional Attributes Name type( photon ), intent(inout) :: packet packet to move through the grid type( cart_grid ), intent(in) :: grid grid that the packet moves through private  subroutine update_pos (packet, grid, pos, celli, cellj, cellk, dcell, wall_flag, dir) routine that upates postions of photon and calls fresnel routines if photon leaves current voxel Arguments Type Intent Optional Attributes Name type( photon ), intent(in) :: packet photon object type( cart_grid ), intent(in) :: grid grid object type( vector ), intent(inout) :: pos current photon position integer, intent(inout) :: celli current voxel ID integer, intent(inout) :: cellj current voxel ID integer, intent(inout) :: cellk current voxel ID real(kind=wp), intent(in) :: dcell distance phton will travel across a cell logical, intent(in) :: wall_flag flag is true if we hit a cell wall logical, intent(in) :: dir (:) logical array. 1 entry is always true. the true entry represents which cell wall we will hit private pure subroutine update_voxels (pos, grid, celli, cellj, cellk) updates the current voxel based upon position Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: pos current photon position vector type( cart_grid ), intent(in) :: grid grid object integer, intent(inout) :: celli current voxel ID. To be updated integer, intent(inout) :: cellj current voxel ID. To be updated integer, intent(inout) :: cellk current voxel ID. To be updated","tags":"","loc":"module/inttau2.html"},{"title":"constants – gridMCRT","text":"Constants used throughout the simulation. Uses iso_fortran_env Contents Variables PI TWOPI fileplace homedir resdir wp Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: PI = 4._wp*atan(1._wp) mathematical constants real(kind=wp), public, parameter :: TWOPI = 2._wp*PI mathematical constants character(len=255), public :: fileplace variables that stores the directory where output files are saved character(len=255), public :: homedir variables that stores the home (root) directory character(len=255), public :: resdir variables that stores the directory for input files. integer, public, parameter :: wp = real64 set working precision as double precision. Lower or higher precisions not tested.","tags":"","loc":"module/constants.html"},{"title":"photon_class – gridMCRT","text":"Module defines the photon class and scattering routines Uses vector_class constants Contents Derived Types photon Subroutines scatter Derived Types type, public :: photon photon type. Encapsulates all information about a single photon. Components Type Visibility Attributes Name Initial real(kind=wp), public :: cosp is the azimuthal angle in the physics spherical coordinate system real(kind=wp), public :: cost is the polar angle in the physics spherical coordinate system type( vector ), public :: dir direction vector real(kind=wp), public :: phi is the azimuthal angle in the physics spherical coordinate system type( vector ), public :: pos position vector real(kind=wp), public :: sinp is the azimuthal angle in the physics spherical coordinate system real(kind=wp), public :: sint . is the polar angle in the physics spherical coordinate system logical, public :: tflag Boolean flag that if true photon is alive and in the simulation integer, public :: xcell Current voxel which the photon is in integer, public :: ycell Current voxel which the photon is in integer, public :: zcell Current voxel which the photon is in Type-Bound Procedures procedure\n                    ,                  public\n,                   :: scatter Subroutine Subroutines public  subroutine scatter (this, opt_prop) photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0)\nadapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html Arguments Type Intent Optional Attributes Name class( photon ) :: this photon packet type( optical_properties ), intent(in) :: opt_prop optical properties","tags":"","loc":"module/photon_class.html"},{"title":"iarray – gridMCRT","text":"Contains all array variable names. Uses constants Contents Variables rhokap Variables Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: rhokap (:,:,:) stores the optical properties, i.e the total cross section","tags":"","loc":"module/iarray.html"},{"title":"vector_class – gridMCRT","text":"Module contains the vector class and associated routines. Uses constants Contents Derived Types vector Functions magnitude_fn scal_add_vec scal_mult_vec vec_add_scal vec_add_vec vec_div_scal vec_dot vec_minus_vec vec_mult_scal vec_mult_vec Subroutines print_sub Derived Types type, public :: vector Vector type used for direction and position vectors\nsupports all possible vector operations Components Type Visibility Attributes Name Initial real(kind=wp), public :: x components of the vector real(kind=wp), public :: y components of the vector real(kind=wp), public :: z components of the vector Type-Bound Procedures procedure\n                    ,                  public\n,                   :: magnitude => magnitude_fn Function get the magnitde of a vector generic,\n                  public\n,                   :: operator(*) => vec_mult_vec , vec_mult_scal , scal_mult_vec multiple a vector by a scalar or vector (element wise) generic,\n                  public\n,                   :: operator(+) => vec_add_vec , vec_add_scal , scal_add_vec add two vectors, or a vector and a scalar generic,\n                  public\n,                   :: operator(-) => vec_minus_vec subtract a vector from a vector generic,\n                  public\n,                   :: operator(.dot.) => vec_dot get the dot product of two vectors generic,\n                  public\n,                   :: operator(/) => vec_div_scal divide a vector by a float procedure\n                    ,                  public\n,                   :: print => print_sub Subroutine print a vector procedure\n                    ,                  private\n, pass(b)                  :: scal_add_vec Function procedure\n                    ,                  private\n, pass(b)                  :: scal_mult_vec Function procedure\n                    ,                  private\n, pass(a)                  :: vec_add_scal Function procedure\n                    ,                  private\n, pass(a)                  :: vec_add_vec Function procedure\n                    ,                  private\n, pass(a)                  :: vec_div_scal Function procedure\n                    ,                  private\n, pass(a)                  :: vec_dot Function procedure\n                    ,                  private\n, pass(a)                  :: vec_minus_vec Function procedure\n                    ,                  private\n, pass(a)                  :: vec_mult_scal Function procedure\n                    ,                  private\n, pass(a)                  :: vec_mult_vec Function Functions private pure function magnitude_fn (this) implmentation of |vector| Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: this Return Value type( vector ) private pure function scal_add_vec (a, b) implmentation of scalar subtract vector\noverloads the + operator Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) private pure function scal_mult_vec (a, b) implmentation of scalar multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) private pure function vec_add_scal (a, b) implmentation of vector add scalar\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) private pure function vec_add_vec (a, b) implmentation of vector add vector\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) private pure function vec_div_scal (a, b) implmentation of vector divide scalar\noverloads the / operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) private pure elemental function vec_dot (a, b) result(dot) implmentation of vector dot vector\ncreates the .dot. operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value real(kind=wp) private pure function vec_minus_vec (a, b) implmentation of vector subtract vector\noverloads the - operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) private pure function vec_mult_scal (a, b) implmentation of vector multiply scalar\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real(kind=wp), intent(in) :: b Return Value type( vector ) private pure function vec_mult_vec (a, b) implmentation of vector multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) Subroutines private  subroutine print_sub (this) prints the vector Arguments Type Intent Optional Attributes Name class( vector ) :: this","tags":"","loc":"module/vector_class.html"},{"title":"optical_properties_class – gridMCRT","text":"Change optical properties\nSet the (scattering coefficient), (absorption coefficient) both in cm , and hgg (g factor). Uses constants Contents Derived Types optical_properties Subroutines init_opt2 init_opt_sphere Derived Types type, public :: optical_properties Stores the optical properties of the medium. Currently only 1 media type. Can expand by making these arrays. Components Type Visibility Attributes Name Initial real(kind=wp), public :: albedo The albedo is real(kind=wp), public :: g2 Is the g factor squared real(kind=wp), public :: hgg hgg is the g factor. Describes the bias of the scattering direction. 1 means forward, 0 isotropic and -1 backscattering. unitless real(kind=wp), public :: kappa is + real(kind=wp), public :: mua is the absorption coefficent. in cm real(kind=wp), public :: mus is the scattering coefficent. in cm Subroutines public  subroutine init_opt2 (opt_prop) Set tissue optical properties 420nm Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop optical property container public  subroutine init_opt_sphere (opt_prop) Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop optical property container","tags":"","loc":"module/optical_properties_class.html"},{"title":"utils – gridMCRT","text":"module that contains utility functions and helper routines. Uses constants Contents Interfaces str Functions str_I32 str_I64 str_R8 str_R8array str_iarray str_logicalarray Subroutines set_directories Interfaces public        interface str functions to turn numerical variables into strings private  function str_I32 (i) convert an int32 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_I64 (i) convert an int64 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_iarray (i) convert an int32 integer array into a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) input int array to convert into string Return Value character(len=:), allocatable private  function str_R8 (i) convert an double precision float into a string Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: i input float to convert into string Return Value character(len=:), allocatable private  function str_R8array (a) convert an double precision float array into a string Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:) input float array to convert into string Return Value character(len=:), allocatable private  function str_logicalarray (a) convert an logical array into a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: a (:) input logical array to convert into string Return Value character(len=:), allocatable Functions private  function str_I32 (i) convert an int32 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_I64 (i) convert an int64 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_R8 (i) convert an double precision float into a string Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: i input float to convert into string Return Value character(len=:), allocatable private  function str_R8array (a) convert an double precision float array into a string Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (:) input float array to convert into string Return Value character(len=:), allocatable private  function str_iarray (i) convert an int32 integer array into a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) input int array to convert into string Return Value character(len=:), allocatable private  function str_logicalarray (a) convert an logical array into a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: a (:) input logical array to convert into string Return Value character(len=:), allocatable Subroutines public  subroutine set_directories () define variables to hold paths to various folders Arguments None","tags":"","loc":"module/utils.html"},{"title":"mcpolar – gridMCRT","text":"Uses utils sourceph_mod writer_mod optical_properties_class photon_class gridset_mod constants random_mod inttau2 *** Read in parameters from the file input.params Contents Variables finish grid j nphotons nscatt nxg nyg nzg opt_prop packet seed start u xmax ymax zmax Source Code mcpolar Variables Type Attributes Name Initial real(kind=wp) :: finish timing vars type( cart_grid ) :: grid variable that holds the 3D grid information integer :: j loop variable integer :: nphotons number of photons to run in the simulation real(kind=wp) :: nscatt counter for number of scatterings for all photons integer :: nxg temp variables related to I/O from param file integer :: nyg temp variables related to I/O from param file integer :: nzg temp variables related to I/O from param file type( optical_properties ) :: opt_prop optical properties variable type( photon ) :: packet variable that holds all information about the photon to be simulated integer :: seed user defined seed real(kind=wp) :: start timing vars integer :: u file handle real(kind=wp) :: xmax temp variables related to I/O from param file real(kind=wp) :: ymax temp variables related to I/O from param file real(kind=wp) :: zmax temp variables related to I/O from param file Source Code program mcpolar !imports use constants , only : resdir , wp use gridset_mod , only : gridset , cart_grid use inttau2 , only : tauint1 use optical_properties_class , only : optical_properties , init_opt_sphere use photon_class , only : photon use random_mod , only : ran2 , init_seed use sourceph_mod , only : isotropic_point_src use utils , only : set_directories , str use writer_mod , only : writer implicit none !> variable that holds all information about the photon to be simulated type ( photon ) :: packet !> variable that holds the 3D grid information type ( cart_grid ) :: grid !> optical properties variable type ( optical_properties ) :: opt_prop !> number of photons to run in the simulation integer :: nphotons !> counter for number of scatterings for all photons real ( kind = wp ) :: nscatt !> user defined seed integer :: seed !> temp variables related to I/O from param file integer :: nxg , nyg , nzg !> loop variable integer :: j !> file handle integer :: u !> temp variables related to I/O from param file real ( kind = wp ) :: xmax , ymax , zmax !> timing vars real ( kind = wp ) :: start , finish call cpu_time ( start ) !set directory paths call set_directories () !set optical properties call init_opt_sphere ( opt_prop ) !set random seed seed = 42 call init_seed ( seed ) !**** Read in parameters from the file input.params open ( newunit = u , file = trim ( resdir ) // 'input.params' , status = 'old' ) read ( u , * ) nphotons read ( u , * ) xmax read ( u , * ) ymax read ( u , * ) zmax read ( u , * ) nxg read ( u , * ) nyg read ( u , * ) nzg close ( u ) print * , '' print * , '# of photons to run' , nphotons ! Set up grid call gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) ! inialise the number of scatterings counter nscatt = 0_wp print * , 'Photons now running' !loop over photons do j = 1 , nphotons !display progress if ( mod ( j , 10000 ) == 0 ) then print * , str ( j ) // ' scattered photons completed' end if ! Release photon from point source call isotropic_point_src ( packet , grid ) ! Find scattering location call tauint1 ( packet , grid ) ! Photon scatters in grid until it exits (tflag=TRUE) do while (. not . packet % tflag ) !interact with medium if ( ran2 () < opt_prop % albedo ) then ! photon is scattered call packet % scatter ( opt_prop ) nscatt = nscatt + 1._wp else ! photon is absorbed packet % tflag = . true . exit end if ! Find next scattering location call tauint1 ( packet , grid ) end do end do ! end loop over nph photons print * , 'Average # of scatters per photon: ' // str ( nscatt / ( nphotons )) !write out files call writer ( grid , nphotons ) print * , 'write done' call cpu_time ( finish ) if ( finish - start >= 6 0._wp ) then print * , floor (( finish - start ) / 6 0._wp ) + mod ( finish - start , 6 0._wp ) / 10 0._wp else print * , 'time taken ~' // str ( floor ( finish - start / 6 0._wp )) // 's' end if end program mcpolar","tags":"","loc":"program/mcpolar.html"},{"title":"gridset.f90 – gridMCRT","text":"Contents Modules gridset_mod Source Code gridset.f90 Source Code module gridset_mod !! Module provides a cartesian grid type to store all grid related variables in a container !! Also provides a way of setting up the geomerty/grid for the simulation. use constants , only : wp use vector_class , only : vector implicit none private public :: gridset , cart_grid !> 3D cartesian grid. Stores information about the linear voxel grid type :: cart_grid !> Size of grid in voxels in each direction integer :: nxg , nyg , nzg !> half size of grid in each dimension. cm type ( vector ) :: dim !> Arrays that store the location of each grid cell(voxel) wall real ( kind = wp ), allocatable :: xface (:), yface (:), zface (:) !> ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls real ( kind = wp ) :: delta end type cart_grid contains subroutine gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) !! Set up grids and create geometry use iarray , only : rhokap , rhokap use optical_properties_class , only : optical_properties !> grid variable that is assigned in this routine type ( cart_grid ), intent ( out ) :: grid !> optical properties used to setup voxel geometry type ( optical_properties ), intent ( in ) :: opt_prop !> number of voxels in each dimension integer , intent ( in ) :: nxg , nyg , nzg !> half size of the grid in cm real ( kind = wp ), intent ( in ) :: xmax , ymax , zmax !> loop variables integer :: i , j , k !> temp variables real ( kind = wp ) :: x , y , z , taueq1 , taupole1 , taueq2 , taupole2 print * , ' ' print * , 'Setting up grid....' ! set grid dimensions and voxel numbers grid % dim = vector ( xmax , ymax , zmax ) grid % nxg = nxg grid % nyg = nyg grid % nzg = nzg ! Set small distance for use in optical depth integration routines ! for roundoff effects when crossing cell walls grid % delta = 1.e-8_wp * ( 2._wp * grid % dim % z / grid % nzg ) ! allocate and set arrays to 0 call alloc_array ( grid ) call zarray ( grid ) ! setup grid cell walls do i = 1 , grid % nxg + 1 grid % xface ( i ) = ( i - 1 ) * 2._wp * grid % dim % x / grid % nxg end do do i = 1 , grid % nyg + 1 grid % yface ( i ) = ( i - 1 ) * 2._wp * grid % dim % y / grid % nyg end do do i = 1 , grid % nzg + 1 grid % zface ( i ) = ( i - 1 ) * 2._wp * grid % dim % z / grid % nzg end do !set up optical properties grid do i = 1 , grid % nxg x = grid % xface ( i ) - grid % dim % x + grid % dim % x / grid % nxg do j = 1 , grid % nyg y = grid % yface ( j ) - grid % dim % y + grid % dim % y / grid % nyg do k = 1 , grid % nzg z = grid % zface ( k ) - grid % dim % z + grid % dim % z / grid % nzg ! create a sphere of radius 1. if ( sqrt ( x ** 2 + y ** 2 + z ** 2 ) <= 1._wp ) then rhokap ( i , j , k ) = opt_prop % kappa else rhokap ( i , j , k ) = 0._wp end if end do end do end do ! Calculate equatorial and polar optical depths ! useful for debugging geometry taueq1 = 0._wp taupole1 = 0._wp taueq2 = 0._wp taupole2 = 0._wp do i = 1 , grid % nxg taueq1 = taueq1 + rhokap ( i , grid % nyg / 2 , grid % nzg / 2 ) end do do i = 1 , grid % nzg taupole1 = taupole1 + rhokap ( grid % nxg / 2 , grid % nyg / 2 , i ) end do taueq1 = taueq1 * 2._wp * grid % dim % x / grid % nxg taupole1 = taupole1 * 2._wp * grid % dim % z / grid % nzg print '(A,F9.5,A,F9.5)' , ' taueq1 = ' , taueq1 , '  taupole1 = ' , taupole1 end subroutine gridset subroutine zarray ( grid ) !! set all 3D arrays to zero use iarray , only : rhokap type ( cart_grid ), intent ( inout ) :: grid rhokap = 0._wp grid % xface = 0._wp grid % yface = 0._wp grid % zface = 0._wp end subroutine zarray subroutine alloc_array ( grid ) !!  allocates allocatable 3D arrays use iarray , only : rhokap type ( cart_grid ), intent ( inout ) :: grid allocate ( rhokap ( grid % nxg , grid % nyg , grid % nzg )) allocate ( grid % xface ( grid % nxg + 1 )) allocate ( grid % yface ( grid % nyg + 1 )) allocate ( grid % zface ( grid % nzg + 1 )) end subroutine alloc_array end module gridset_mod","tags":"","loc":"sourcefile/gridset.f90.html"},{"title":"random_mod.f90 – gridMCRT","text":"Contents Modules random_mod Source Code random_mod.f90 Source Code module random_mod !! module containg routines related to random numbers use constants , only : wp implicit none private public :: ran2 , ranu , init_seed contains subroutine init_seed ( seed ) !! user convenience function for setting random generator seed !> user defined seed integer , intent ( in ) :: seed !> size of internal seed array integer :: n !> internal seed array to be filled with user defined seed integer , allocatable :: iseed (:) ! get seed size call random_seed ( size = n ) allocate ( iseed ( n )) ! put user seed in actual seed iseed = seed ! seed the RNG call random_seed ( put = iseed ) end subroutine init_seed real ( kind = wp ) function ran2 () !! Wrapper function to fortran internal random number generator !! Generates a random number in the range [0,1.) call random_number ( ran2 ) end function ran2 real ( kind = wp ) function ranu ( a , b ) !! sample uniformly between [a, b] !> input lower bound real ( kind = wp ), intent ( in ) :: a !> input upper bound real ( kind = wp ), intent ( in ) :: b ranu = a + ran2 () * ( b - a ) end function ranu end module random_mod","tags":"","loc":"sourcefile/random_mod.f90.html"},{"title":"sourceph.f90 – gridMCRT","text":"Contents Modules sourceph_mod Source Code sourceph.f90 Source Code module sourceph_mod !! Module contains the routines to inialise a photon, i.e different light sources. implicit none contains subroutine isotropic_point_src ( packet , grid ) !! set intial photon position at (0.0, 0.0, 0.0) and sample photon direction in an isotropic manner. use constants , only : TWOPI , wp use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 !> photon object type ( photon ), intent ( out ) :: packet !> grid object type ( cart_grid ), intent ( in ) :: grid !set packet position packet % pos % z = 0.0_wp packet % pos % x = 0.0_wp packet % pos % y = 0.0_wp ! set packet cosines packet % phi = ran2 () * twoPI packet % cosp = cos ( packet % phi ) packet % sinp = sin ( packet % phi ) packet % cost = 2._wp * ran2 () - 1._wp packet % sint = sqrt ( 1._wp - packet % cost ** 2 ) ! set direction vector packet % dir % x = packet % sint * packet % cosp packet % dir % y = packet % sint * packet % sinp packet % dir % z = packet % cost ! set packet voxel packet % xcell = int ( grid % nxg * ( packet % pos % x + grid % dim % x ) / ( 2._wp * grid % dim % x )) + 1 packet % ycell = int ( grid % nyg * ( packet % pos % y + grid % dim % y ) / ( 2._wp * grid % dim % y )) + 1 packet % zcell = int ( grid % nzg * ( packet % pos % z + grid % dim % z ) / ( 2._wp * grid % dim % z )) + 1 packet % tflag = . false . end subroutine isotropic_point_src end module sourceph_mod","tags":"","loc":"sourcefile/sourceph.f90.html"},{"title":"writer.f90 – gridMCRT","text":"Contents Modules writer_mod Source Code writer.f90 Source Code module writer_mod !! I/O related routines. implicit none contains subroutine writer ( grid , nphotons ) !! subroutine to write out normalised fluence use constants , only : fileplace use gridset_mod , only : cart_grid !> grid type ( cart_grid ), intent ( in ) :: grid !> number of photons to normalise by integer , intent ( in ) :: nphotons ! normalise fluence assuming power is 1W ! write out fluence end subroutine writer end module writer_mod","tags":"","loc":"sourcefile/writer.f90.html"},{"title":"inttau2.f90 – gridMCRT","text":"Contents Modules inttau2 Source Code inttau2.f90 Source Code module inttau2 !! module contains routines related to the optical depth integration of a photon though a 3D grid. use constants , only : wp implicit none private public :: tauint1 CONTAINS subroutine tauint1 ( packet , grid ) !! optical depth integration subroutine. The main workhorse of MCRT use gridset_mod , only : cart_grid use iarray , only : rhokap use photon_class , only : photon use random_mod , only : ran2 use vector_class , only : vector !> packet to move through the grid type ( photon ), intent ( inout ) :: packet !> grid that the packet moves through type ( cart_grid ), intent ( in ) :: grid ! intermediate position type ( vector ) :: pos real ( kind = wp ) :: tau , taurun , taucell , d , dcell integer :: celli , cellj , cellk logical :: dir ( 3 ) !change grid origin to lower left of the grid pos = packet % pos + grid % dim ! store current voxel in temp variables celli = packet % xcell cellj = packet % ycell cellk = packet % zcell ! setup to start integrating taurun = 0._wp d = 0._wp dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !sample optical distance tau = - log ( ran2 ()) do dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !get distance to nearest wall in direction dir dcell = wall_dist ( packet , grid , celli , cellj , cellk , pos , dir ) !calculate optical distnace to cell wall taucell = dcell * rhokap ( celli , cellj , cellk ) if ( taurun + taucell < tau ) then !still some tau to move taurun = taurun + taucell d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . TRUE ., dir ) else !moved full distance dcell = ( tau - taurun ) / rhokap ( celli , cellj , cellk ) d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . FALSE ., dir ) exit end if if ( celli == - 1 . or . cellj == - 1 . or . cellk == - 1 ) then packet % tflag = . true . exit end if end do ! move back to grid with origin at the centre packet % pos = pos - grid % dim packet % xcell = celli packet % ycell = cellj packet % zcell = cellk end subroutine tauint1 real ( kind = wp ) function wall_dist ( packet , grid , celli , cellj , cellk , pos , dir ) !!function that returns distant to nearest wall and which wall that is (x ,y or z) use gridset_mod , only : cart_grid use photon_class , only : photon use vector_class , only : vector !> photon packet type ( photon ), intent ( inout ) :: packet !> grid variable container type ( cart_grid ), intent ( in ) :: grid !> current position type ( vector ), intent ( inout ) :: pos !> which wall will we hit. Stored as array of bools logical , intent ( inout ) :: dir (:) !> current voxel ID integer , intent ( inout ) :: celli , cellj , cellk real ( kind = wp ) :: dx , dy , dz ! get distance to a wall in the x direction if ( packet % dir % x > 0._wp ) then dx = ( grid % xface ( celli + 1 ) - pos % x ) / packet % dir % x elseif ( packet % dir % x < 0._wp ) then dx = ( grid % xface ( celli ) - pos % x ) / packet % dir % x elseif ( packet % dir % x == 0._wp ) then dx = 10000 0._wp end if ! get distance to a wall in the y direction if ( packet % dir % y > 0._wp ) then dy = ( grid % yface ( cellj + 1 ) - pos % y ) / packet % dir % y elseif ( packet % dir % y < 0._wp ) then dy = ( grid % yface ( cellj ) - pos % y ) / packet % dir % y elseif ( packet % dir % y == 0._wp ) then dy = 10000 0._wp end if ! get distance to a wall in the z direction if ( packet % dir % z > 0._wp ) then dz = ( grid % zface ( cellk + 1 ) - pos % z ) / packet % dir % z elseif ( packet % dir % z < 0._wp ) then dz = ( grid % zface ( cellk ) - pos % z ) / packet % dir % z elseif ( packet % dir % z == 0._wp ) then dz = 10000 0._wp end if !get closest wall wall_dist = min ( dx , dy , dz ) if ( wall_dist < 0._wp ) print '(A,7F9.5)' , 'dcell < 0.0 warning! ' , wall_dist , dx , dy , dz , packet % dir if ( wall_dist == dx ) dir = ( / . TRUE ., . FALSE ., . FALSE . / ) if ( wall_dist == dy ) dir = ( / . FALSE ., . TRUE ., . FALSE . / ) if ( wall_dist == dz ) dir = ( / . FALSE ., . FALSE ., . TRUE . / ) if (. not . dir ( 1 ) . and . . not . dir ( 2 ) . and . . not . dir ( 3 )) print * , 'Error in dir flag' end function wall_dist subroutine update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , wall_flag , dir ) !! routine that upates postions of photon and calls fresnel routines if photon leaves current voxel use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 use utils , only : str use vector_class , only : vector !> photon object type ( photon ), intent ( in ) :: packet !> current photon position type ( vector ), intent ( inout ) :: pos !> grid object type ( cart_grid ), intent ( in ) :: grid !> distance phton will travel across a cell real ( kind = wp ), intent ( in ) :: dcell !> current voxel ID integer , intent ( inout ) :: celli , cellj , cellk !> flag is true if we hit a cell wall logical , intent ( in ) :: wall_flag !> logical array. 1 entry is always true. the true entry represents which cell wall we will hit logical , intent ( in ) :: dir (:) ! if we hit a wall if ( wall_flag ) then ! in the x direction if ( dir ( 1 )) then if ( packet % dir % x > 0._wp ) then pos % x = grid % xface ( celli + 1 ) + grid % delta celli = celli + 1 elseif ( packet % dir % x < 0._wp ) then pos % x = grid % xface ( celli ) - grid % delta celli = celli - 1 else error stop 'Error in x dir in update_pos' end if pos % y = pos % y + packet % dir % y * dcell pos % z = pos % z + packet % dir % z * dcell ! y direction elseif ( dir ( 2 )) then if ( packet % dir % y > 0._wp ) then pos % y = grid % yface ( cellj + 1 ) + grid % delta cellj = cellj + 1 elseif ( packet % dir % y < 0._wp ) then pos % y = grid % yface ( cellj ) - grid % delta cellj = cellj - 1 else error stop 'Error in y dir in update_pos' end if pos % x = pos % x + packet % dir % x * dcell pos % z = pos % z + packet % dir % z * dcell ! z direction elseif ( dir ( 3 )) then if ( packet % dir % z > 0._wp ) then pos % z = grid % zface ( cellk + 1 ) + grid % delta cellk = cellk + 1 elseif ( packet % dir % z < 0._wp ) then pos % z = grid % zface ( cellk ) - grid % delta cellk = cellk - 1 else error stop 'Error in z dir in update_pos' end if pos % x = pos % x + packet % dir % x * dcell pos % y = pos % y + packet % dir % y * dcell else error stop 'Error in update_pos...' end if else ! we dont hit a wall pos = pos + packet % dir * dcell end if if ( wall_flag ) then ! if we hit a wall, get current voxel call update_voxels ( pos , grid , celli , cellj , cellk ) end if end subroutine update_pos pure subroutine update_voxels ( pos , grid , celli , cellj , cellk ) !! updates the current voxel based upon position use gridset_mod , only : cart_grid use vector_class , only : vector !> current photon position vector type ( vector ), intent ( in ) :: pos !> grid object type ( cart_grid ), intent ( in ) :: grid !> current voxel ID. To be updated integer , intent ( inout ) :: celli , cellj , cellk celli = floor ( grid % nxg * ( pos % x ) / ( 2._wp * grid % dim % x )) + 1 cellj = floor ( grid % nyg * ( pos % y ) / ( 2._wp * grid % dim % y )) + 1 cellk = floor ( grid % nzg * ( pos % z ) / ( 2._wp * grid % dim % z )) + 1 if ( celli > grid % nxg . or . celli < 1 ) celli = - 1 if ( cellj > grid % nyg . or . cellj < 1 ) cellj = - 1 if ( cellk > grid % nzg . or . cellk < 1 ) cellk = - 1 end subroutine update_voxels end module inttau2","tags":"","loc":"sourcefile/inttau2.f90.html"},{"title":"constants.f90 – gridMCRT","text":"Contents Modules constants Source Code constants.f90 Source Code module constants !! Constants used throughout the simulation. use iso_fortran_env , only : real64 , real32 implicit none !> set working precision as double precision. Lower or higher precisions not tested. integer , parameter :: wp = real64 !> mathematical constants real ( kind = wp ), parameter :: PI = 4._wp * atan ( 1._wp ), TWOPI = 2._wp * PI !> variables that stores the home (root) directory character ( len = 255 ) :: homedir !> variables that stores the directory where output files are saved character ( len = 255 ) :: fileplace !> variables that stores the directory for input files. character ( len = 255 ) :: resdir end module constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"photon_class.f90 – gridMCRT","text":"Contents Modules photon_class Source Code photon_class.f90 Source Code module photon_class !! Module defines the photon class and scattering routines use constants , only : wp use vector_class , only : vector implicit none !> photon type. Encapsulates all information about a single photon. type :: photon !> direction vector type ( vector ) :: dir !> position vector type ( vector ) :: pos !> sin(theta). \\theta is the polar angle in the physics spherical coordinate system real ( kind = wp ) :: sint !> cos(\\theta) \\theta is the polar angle in the physics spherical coordinate system real ( kind = wp ) :: cost !> sin(\\phi) \\phi is the azimuthal angle in the physics spherical coordinate system real ( kind = wp ) :: sinp !> cos(\\phi) \\phi is the azimuthal angle in the physics spherical coordinate system real ( kind = wp ) :: cosp !> \\phi \\phi is the azimuthal angle in the physics spherical coordinate system real ( kind = wp ) :: phi !> Boolean flag that if true photon is alive and in the simulation logical :: tflag !> Current voxel which the photon is in integer :: xcell , ycell , zcell contains procedure :: scatter end type photon contains subroutine scatter ( this , opt_prop ) !! photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0) !! adapted from mcxyz [https://omlc.org/software/mc/mcxyz/index.html](https://omlc.org/software/mc/mcxyz/index.html) use optical_properties_class , only : optical_properties use constants , only : PI , TWOPI use random_mod , only : ran2 !> photon packet class ( photon ) :: this !> optical properties type ( optical_properties ), intent ( in ) :: opt_prop real ( kind = wp ) :: temp , uxx , uyy , uzz if ( opt_prop % hgg == 0.0_wp ) then !isotropic scattering this % cost = 2._wp * ran2 () - 1._wp else !henyey-greenstein scattering temp = ( 1.0_wp - opt_prop % g2 ) / ( 1.0_wp - opt_prop % hgg + 2._wp * opt_prop % hgg * ran2 ()) this % cost = ( 1.0_wp + opt_prop % g2 - temp ** 2 ) / ( 2._wp * opt_prop % hgg ) end if this % sint = sqrt ( 1._wp - this % cost ** 2 ) this % phi = TWOPI * ran2 () this % cosp = cos ( this % phi ) if ( this % phi < PI ) then this % sinp = sqrt ( 1._wp - this % cosp ** 2 ) else this % sinp = - sqrt ( 1._wp - this % cosp ** 2 ) end if if ( 1._wp - abs ( this % dir % z ) <= 1e-12_wp ) then ! near perpindicular uxx = this % sint * this % cosp uyy = this % sint * this % sinp uzz = sign ( this % cost , this % dir % z ) else temp = sqrt ( 1._wp - this % dir % z ** 2 ) uxx = this % sint * ( this % dir % x * this % dir % z * this % cosp - this % dir % y * this % sinp ) & / temp + this % dir % x * this % cost uyy = this % sint * ( this % dir % y * this % dir % z * this % cosp + this % dir % x * this % sinp ) & / temp + this % dir % y * this % cost uzz = - 1. * this % sint * this % cosp * temp + this % dir % z * this % cost end if this % dir % x = uxx this % dir % y = uyy this % dir % z = uzz end subroutine scatter end module photon_class","tags":"","loc":"sourcefile/photon_class.f90.html"},{"title":"iarray.f90 – gridMCRT","text":"Contents Modules iarray Source Code iarray.f90 Source Code module iarray !!  Contains all array variable names. use constants , only : wp implicit none !> stores the optical properties, i.e the total cross section \\mu_t = \\mu_s + \\mu_a real ( kind = wp ), allocatable :: rhokap (:,:,:) end module iarray","tags":"","loc":"sourcefile/iarray.f90.html"},{"title":"vector_class.f90 – gridMCRT","text":"Contents Modules vector_class Source Code vector_class.f90 Source Code Module vector_class !! Module contains the vector class and associated routines. use constants , only : wp implicit none !> Vector type used for direction and position vectors !> supports all possible vector operations type :: vector !> components of the vector real ( kind = wp ) :: x , y , z contains !> get the magnitde of a vector procedure :: magnitude => magnitude_fn !> print a vector procedure :: print => print_sub !> get the dot product of two vectors generic :: operator (. dot .) => vec_dot !> divide a vector by a float generic :: operator ( / ) => vec_div_scal !> multiple a vector by a scalar or vector (element wise) generic :: operator ( * ) => vec_mult_vec , vec_mult_scal , scal_mult_vec !> add two vectors, or a vector and a scalar generic :: operator ( + ) => vec_add_vec , vec_add_scal , scal_add_vec !> subtract a vector from a vector generic :: operator ( - ) => vec_minus_vec procedure , pass ( a ), private :: vec_dot procedure , pass ( a ), private :: vec_div_scal procedure , pass ( a ), private :: vec_mult_vec procedure , pass ( a ), private :: vec_mult_scal procedure , pass ( b ), private :: scal_mult_vec procedure , pass ( a ), private :: vec_add_vec procedure , pass ( a ), private :: vec_add_scal procedure , pass ( b ), private :: scal_add_vec procedure , pass ( a ), private :: vec_minus_vec end type vector private public :: vector contains pure type ( vector ) function vec_minus_vec ( a , b ) !! implmentation of vector subtract vector !! overloads the - operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_minus_vec = vector ( a % x - b % x , a % y - b % y , a % z - b % z ) end function vec_minus_vec pure type ( vector ) function vec_add_scal ( a , b ) !! implmentation of vector add scalar !! overloads the + operator class ( vector ), intent ( IN ) :: a real ( kind = wp ), intent ( IN ) :: b vec_add_scal = vector ( a % x + b , a % y + b , a % z + b ) end function vec_add_scal pure type ( vector ) function scal_add_vec ( a , b ) !! implmentation of scalar subtract vector !! overloads the + operator class ( vector ), intent ( IN ) :: b real ( kind = wp ), intent ( IN ) :: a scal_add_vec = vector ( b % x + a , b % y + a , b % z + a ) end function scal_add_vec pure type ( vector ) function vec_add_vec ( a , b ) !! implmentation of vector add vector !! overloads the + operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_add_vec = vector ( a % x + b % x , a % y + b % y , a % z + b % z ) end function vec_add_vec pure elemental function vec_dot ( a , b ) result ( dot ) !! implmentation of vector dot vector !! creates the .dot. operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b real ( kind = wp ) :: dot dot = ( a % x * b % x ) + ( a % y * b % y ) + ( a % z * b % z ) end function vec_dot pure type ( vector ) function vec_mult_vec ( a , b ) !! implmentation of vector multiply vector !! overloads the * operator !@note !    This is ELEMENT wise multiplication !@end note class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_mult_vec = vector ( a % x * b % x , a % y * b % y , a % z * b % z ) end function vec_mult_vec pure type ( vector ) function vec_mult_scal ( a , b ) !! implmentation of vector multiply scalar !! overloads the * operator class ( vector ), intent ( IN ) :: a real ( kind = wp ), intent ( IN ) :: b vec_mult_scal = vector ( a % x * b , a % y * b , a % z * b ) end function vec_mult_scal pure type ( vector ) function scal_mult_vec ( a , b ) !! implmentation of scalar multiply vector !! overloads the * operator class ( vector ), intent ( IN ) :: b real ( kind = wp ), intent ( IN ) :: a scal_mult_vec = vector ( a * b % x , a * b % y , a * b % z ) end function scal_mult_vec pure type ( vector ) function vec_div_scal ( a , b ) !! implmentation of vector divide scalar !! overloads the / operator class ( vector ), intent ( IN ) :: a real ( kind = wp ), intent ( IN ) :: b vec_div_scal = vector ( a % x / b , a % y / b , a % z / b ) end function vec_div_scal pure type ( vector ) function magnitude_fn ( this ) !! implmentation of |vector| class ( vector ), intent ( in ) :: this real ( kind = wp ) :: tmp tmp = sqrt ( this % x ** 2 + this % y ** 2 + this % z ** 2 ) magnitude_fn = this / tmp end function magnitude_fn subroutine print_sub ( this ) !! prints the vector class ( vector ) :: this print * , this % x , this % y , this % z end subroutine print_sub end Module vector_class","tags":"","loc":"sourcefile/vector_class.f90.html"},{"title":"optical_properties.f90 – gridMCRT","text":"Contents Modules optical_properties_class Source Code optical_properties.f90 Source Code module optical_properties_class !! Change optical properties !! Set the \\mu_s (scattering coefficient), \\mu_a(absorption coefficient) both in cm&#94;{-1}, and hgg (g factor). use constants , only : wp implicit none !> Stores the optical properties of the medium. Currently only 1 media type. Can expand by making these arrays. type :: optical_properties !> \\mu_s is the scattering coefficent. in cm&#94;{-1} real ( kind = wp ) :: mus !> \\mu_a is the absorption coefficent. in cm&#94;{-1} real ( kind = wp ) :: mua !> hgg is the g factor. Describes the bias of the scattering direction. 1 means forward, 0 isotropic and -1 backscattering. unitless real ( kind = wp ) :: hgg !> Is the g factor squared real ( kind = wp ) :: g2 !> \\kappa is \\mu_s + \\mu_a real ( kind = wp ) :: kappa !> The albedo is \\frac{\\mu_s}{\\mu_a+\\mu_s} real ( kind = wp ) :: albedo end type optical_properties private public :: optical_properties , init_opt_sphere , init_opt2 contains subroutine init_opt_sphere ( opt_prop ) !!  Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. !> optical property container type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.0_wp opt_prop % g2 = opt_prop % hgg ** 2._wp opt_prop % mua = 0.0_wp opt_prop % mus = 1 0.0_wp opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt_sphere subroutine init_opt2 ( opt_prop ) !!  Set tissue optical properties 420nm !> optical property container type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.9_wp opt_prop % g2 = opt_prop % hgg ** 2._wp opt_prop % mua = 1.8_wp opt_prop % mus = 8 2.0_wp / ( 1.0_wp - opt_prop % hgg ) opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt2 end module optical_properties_class","tags":"","loc":"sourcefile/optical_properties.f90.html"},{"title":"utils.f90 – gridMCRT","text":"Contents Modules utils Source Code utils.f90 Source Code module utils !! module that contains utility functions and helper routines. use constants , only : wp implicit none !>functions to turn numerical variables into strings interface str module procedure str_I32 module procedure str_I64 module procedure str_Iarray module procedure str_R8 module procedure str_R8array module procedure str_logicalarray end interface str private public :: str , set_directories contains subroutine set_directories () !! define variables to hold paths to various folders use constants , only : homedir , fileplace , resdir character ( len = 255 ) :: cwd !get current working directory call get_environment_variable ( 'PWD' , cwd ) ! get 'home' dir from cwd if ( index ( cwd , \"bin\" ) > 0 ) then ! if program is run from bin dir homedir = trim ( cwd ( 1 : len ( trim ( cwd )) - 3 )) else ! program is run from root dir homedir = trim ( cwd ) // \"/\" end if ! get data dir fileplace = trim ( homedir ) // 'data/' ! get res dir resdir = trim ( homedir ) // 'res/' end subroutine set_directories function str_I32 ( i ) !! convert an int32 integer into a string use iso_fortran_env , only : Int32 !> input int to convert into string integer ( int32 ), intent ( IN ) :: i character ( len = :), allocatable :: str_I32 character ( len = 100 ) :: string write ( string , '(I100.1)' ) I str_I32 = trim ( adjustl ( string )) end function str_I32 function str_I64 ( i ) !! convert an int64 integer into a string use iso_fortran_env , only : Int64 !> input int to convert into string integer ( Int64 ), intent ( IN ) :: i character ( len = :), allocatable :: str_I64 character ( len = 100 ) :: string write ( string , '(I100.1)' ) I str_I64 = trim ( adjustl ( string )) end function str_I64 function str_iarray ( i ) !! convert an int32 integer array into a string !> input int array to convert into string integer , intent ( IN ) :: i (:) character ( len = :), allocatable :: str_iarray character ( len = 100 ) :: string integer :: j do j = 1 , size ( i ) write ( string , '(I100.1)' ) I ( j ) str_iarray = str_iarray // ' ' // trim ( adjustl ( string )) end do end function str_iarray function str_R8 ( i ) !! convert an double precision float into a string !> input float to convert into string real ( kind = wp ), intent ( IN ) :: i character ( len = :), allocatable :: str_R8 character ( len = 100 ) :: string write ( string , '(f100.16)' ) I str_R8 = trim ( adjustl ( string )) end function str_r8 function str_R8array ( a ) !! convert an double precision float array into a string !> input float array to convert into string real ( kind = wp ), intent ( IN ) :: a (:) character ( len = :), allocatable :: str_R8array character ( len = 100 ) :: string integer :: i do i = 1 , size ( a ) write ( string , '(f100.16)' ) a ( i ) str_R8array = str_R8array // ' ' // trim ( adjustl ( string )) end do end function str_R8array function str_logicalarray ( a ) !! convert an logical array into a string !> input logical array to convert into string logical , intent ( IN ) :: a (:) character ( len = :), allocatable :: str_logicalarray character ( len = 100 ) :: string integer :: i do i = 1 , size ( a ) write ( string , '(L1)' ) a ( i ) str_logicalarray = str_logicalarray // ' ' // trim ( adjustl ( string )) end do end function str_logicalarray end module utils","tags":"","loc":"sourcefile/utils.f90.html"},{"title":"mcpolar.f90 – gridMCRT","text":"Contents Programs mcpolar Source Code mcpolar.f90 Source Code program mcpolar !imports use constants , only : resdir , wp use gridset_mod , only : gridset , cart_grid use inttau2 , only : tauint1 use optical_properties_class , only : optical_properties , init_opt_sphere use photon_class , only : photon use random_mod , only : ran2 , init_seed use sourceph_mod , only : isotropic_point_src use utils , only : set_directories , str use writer_mod , only : writer implicit none !> variable that holds all information about the photon to be simulated type ( photon ) :: packet !> variable that holds the 3D grid information type ( cart_grid ) :: grid !> optical properties variable type ( optical_properties ) :: opt_prop !> number of photons to run in the simulation integer :: nphotons !> counter for number of scatterings for all photons real ( kind = wp ) :: nscatt !> user defined seed integer :: seed !> temp variables related to I/O from param file integer :: nxg , nyg , nzg !> loop variable integer :: j !> file handle integer :: u !> temp variables related to I/O from param file real ( kind = wp ) :: xmax , ymax , zmax !> timing vars real ( kind = wp ) :: start , finish call cpu_time ( start ) !set directory paths call set_directories () !set optical properties call init_opt_sphere ( opt_prop ) !set random seed seed = 42 call init_seed ( seed ) !**** Read in parameters from the file input.params open ( newunit = u , file = trim ( resdir ) // 'input.params' , status = 'old' ) read ( u , * ) nphotons read ( u , * ) xmax read ( u , * ) ymax read ( u , * ) zmax read ( u , * ) nxg read ( u , * ) nyg read ( u , * ) nzg close ( u ) print * , '' print * , '# of photons to run' , nphotons ! Set up grid call gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) ! inialise the number of scatterings counter nscatt = 0_wp print * , 'Photons now running' !loop over photons do j = 1 , nphotons !display progress if ( mod ( j , 10000 ) == 0 ) then print * , str ( j ) // ' scattered photons completed' end if ! Release photon from point source call isotropic_point_src ( packet , grid ) ! Find scattering location call tauint1 ( packet , grid ) ! Photon scatters in grid until it exits (tflag=TRUE) do while (. not . packet % tflag ) !interact with medium if ( ran2 () < opt_prop % albedo ) then ! photon is scattered call packet % scatter ( opt_prop ) nscatt = nscatt + 1._wp else ! photon is absorbed packet % tflag = . true . exit end if ! Find next scattering location call tauint1 ( packet , grid ) end do end do ! end loop over nph photons print * , 'Average # of scatters per photon: ' // str ( nscatt / ( nphotons )) !write out files call writer ( grid , nphotons ) print * , 'write done' call cpu_time ( finish ) if ( finish - start >= 6 0._wp ) then print * , floor (( finish - start ) / 6 0._wp ) + mod ( finish - start , 6 0._wp ) / 10 0._wp else print * , 'time taken ~' // str ( floor ( finish - start / 6 0._wp )) // 's' end if end program mcpolar","tags":"","loc":"sourcefile/mcpolar.f90.html"}]}