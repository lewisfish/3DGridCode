var tipuesearch = {"pages":[{"title":" gridMCRT ","text":"gridMCRT Brief description License Brief description A Monte Carlo radiation transfer (MCRT) code with voxels representing the geometry, written in modern Fortran.\nThe code is setup to run a MCRT simulation in a sphere, radius 1cm, with isotropic scattering properties and an albedo of 1.\nPhotons are released isotropically from the center of the sphere. The output should give the average number of scatterings as ~57. You can browse the structure of the code using the tabs at the top of the page for more information on how the code is structured.\nThe input file, res/input.params, sets the input parameters of the simulation. Original code was by K. Wood. Current version was heavily modified converted to modern Fortran by L. McMillan. License The gridMCRT source code and related files and documentation are distributed under a permissive free software license (MIT). Developer Info Lewis McMillan, Kenny Wood","tags":"home","loc":"index.html"},{"title":"photon – gridMCRT ","text":"type, public :: photon photon type. Encapsulates all information about a single photon. Inherits type~~photon~~InheritsGraph type~photon photon type~vector vector type~photon->type~vector dir, pos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables cosp cost dir phi pos sinp sint tflag xcell ycell zcell Type-Bound Procedures scatter Source Code photon Components Type Visibility Attributes Name Initial real, public :: cosp is the azimuthal angle in the physics spherical coordinate system real, public :: cost is the polar angle in the physics spherical coordinate system type( vector ), public :: dir direction vector real, public :: phi is the azimuthal angle in the physics spherical coordinate system type( vector ), public :: pos position vector real, public :: sinp is the azimuthal angle in the physics spherical coordinate system real, public :: sint . is the polar angle in the physics spherical coordinate system logical, public :: tflag Boolean flag that if true photon is alive and in the simulation integer, public :: xcell Current voxel which the photon is in integer, public :: ycell Current voxel which the photon is in integer, public :: zcell Current voxel which the photon is in Type-Bound Procedures procedure, public :: scatter public  subroutine scatter (this, opt_prop) photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0)\nadapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html Arguments Type Intent Optional Attributes Name class( photon ) :: this photon packet type( optical_properties ), intent(in) :: opt_prop optical properties Source Code type :: photon !> direction vector type ( vector ) :: dir !> position vector type ( vector ) :: pos !> sin(theta). \\theta is the polar angle in the physics spherical coordinate system real :: sint !> cos(\\theta) \\theta is the polar angle in the physics spherical coordinate system real :: cost !> sin(\\phi) \\phi is the azimuthal angle in the physics spherical coordinate system real :: sinp !> cos(\\phi) \\phi is the azimuthal angle in the physics spherical coordinate system real :: cosp !> \\phi \\phi is the azimuthal angle in the physics spherical coordinate system real :: phi !> Boolean flag that if true photon is alive and in the simulation logical :: tflag !> Current voxel which the photon is in integer :: xcell , ycell , zcell contains procedure :: scatter end type photon","tags":"","loc":"type/photon.html"},{"title":"cart_grid – gridMCRT ","text":"type, public :: cart_grid 3D cartesian grid. Stores information about the linear voxel grid Inherits type~~cart_grid~~InheritsGraph type~cart_grid cart_grid type~vector vector type~cart_grid->type~vector dim Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables delta dim nxg nyg nzg xface yface zface Source Code cart_grid Components Type Visibility Attributes Name Initial real, public :: delta ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls type( vector ), public :: dim half size of grid in each dimension. cm integer, public :: nxg Size of grid in voxels in each direction integer, public :: nyg Size of grid in voxels in each direction integer, public :: nzg Size of grid in voxels in each direction real, public, allocatable :: xface (:) Arrays that store the location of each grid cell(voxel) wall real, public, allocatable :: yface (:) Arrays that store the location of each grid cell(voxel) wall real, public, allocatable :: zface (:) Arrays that store the location of each grid cell(voxel) wall Source Code type :: cart_grid !> Size of grid in voxels in each direction integer :: nxg , nyg , nzg !> half size of grid in each dimension. cm type ( vector ) :: dim !> Arrays that store the location of each grid cell(voxel) wall real , allocatable :: xface (:), yface (:), zface (:) !> ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls real :: delta end type cart_grid","tags":"","loc":"type/cart_grid.html"},{"title":"vector – gridMCRT ","text":"type, public :: vector Vector type used for direction and position vectors\nsupports all possible vector operations Inherited by type~~vector~~InheritedByGraph type~vector vector type~cart_grid cart_grid type~cart_grid->type~vector dim type~photon photon type~photon->type~vector dir, pos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables x y z Type-Bound Procedures magnitude operator(*) operator(+) operator(-) operator(.dot.) operator(/) print scal_add_vec scal_mult_vec vec_add_scal vec_add_vec vec_div_scal vec_dot vec_minus_vec vec_mult_scal vec_mult_vec Source Code vector Components Type Visibility Attributes Name Initial real, public :: x components of the vector real, public :: y components of the vector real, public :: z components of the vector Type-Bound Procedures procedure, public :: magnitude => magnitude_fn get the magnitde of a vector private pure function magnitude_fn (this) implmentation of |vector| Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: this Return Value type( vector ) generic, public :: operator(*) => vec_mult_vec , vec_mult_scal , scal_mult_vec multiple a vector by a scalar or vector (element wise) private pure function vec_mult_vec (a, b) implmentation of vector multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) private pure function vec_mult_scal (a, b) implmentation of vector multiply scalar\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) private pure function scal_mult_vec (a, b) implmentation of scalar multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name real, intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) generic, public :: operator(+) => vec_add_vec , vec_add_scal , scal_add_vec add two vectors, or a vector and a scalar private pure function vec_add_vec (a, b) implmentation of vector add vector\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) private pure function vec_add_scal (a, b) implmentation of vector add scalar\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) private pure function scal_add_vec (a, b) implmentation of scalar subtract vector\noverloads the + operator Arguments Type Intent Optional Attributes Name real, intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) generic, public :: operator(-) => vec_minus_vec subtract a vector from a vector private pure function vec_minus_vec (a, b) implmentation of vector subtract vector\noverloads the - operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) generic, public :: operator(.dot.) => vec_dot get the dot product of two vectors private pure elemental function vec_dot (a, b) result(dot) implmentation of vector dot vector\ncreates the .dot. operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value real generic, public :: operator(/) => vec_div_scal divide a vector by a float private pure function vec_div_scal (a, b) implmentation of vector divide scalar\noverloads the / operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) procedure, public :: print => print_sub print a vector private  subroutine print_sub (this) prints the vector Arguments Type Intent Optional Attributes Name class( vector ) :: this procedure, private, pass(b) :: scal_add_vec private pure function scal_add_vec (a, b) implmentation of scalar subtract vector\noverloads the + operator Arguments Type Intent Optional Attributes Name real, intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) procedure, private, pass(b) :: scal_mult_vec private pure function scal_mult_vec (a, b) implmentation of scalar multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name real, intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_add_scal private pure function vec_add_scal (a, b) implmentation of vector add scalar\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_add_vec private pure function vec_add_vec (a, b) implmentation of vector add vector\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_div_scal private pure function vec_div_scal (a, b) implmentation of vector divide scalar\noverloads the / operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_dot private pure elemental function vec_dot (a, b) result(dot) implmentation of vector dot vector\ncreates the .dot. operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value real procedure, private, pass(a) :: vec_minus_vec private pure function vec_minus_vec (a, b) implmentation of vector subtract vector\noverloads the - operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_mult_scal private pure function vec_mult_scal (a, b) implmentation of vector multiply scalar\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) procedure, private, pass(a) :: vec_mult_vec private pure function vec_mult_vec (a, b) implmentation of vector multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) Source Code type :: vector !> components of the vector real :: x , y , z contains !> get the magnitde of a vector procedure :: magnitude => magnitude_fn !> print a vector procedure :: print => print_sub !> get the dot product of two vectors generic :: operator (. dot .) => vec_dot !> divide a vector by a float generic :: operator ( / ) => vec_div_scal !> multiple a vector by a scalar or vector (element wise) generic :: operator ( * ) => vec_mult_vec , vec_mult_scal , scal_mult_vec !> add two vectors, or a vector and a scalar generic :: operator ( + ) => vec_add_vec , vec_add_scal , scal_add_vec !> subtract a vector from a vector generic :: operator ( - ) => vec_minus_vec procedure , pass ( a ), private :: vec_dot procedure , pass ( a ), private :: vec_div_scal procedure , pass ( a ), private :: vec_mult_vec procedure , pass ( a ), private :: vec_mult_scal procedure , pass ( b ), private :: scal_mult_vec procedure , pass ( a ), private :: vec_add_vec procedure , pass ( a ), private :: vec_add_scal procedure , pass ( b ), private :: scal_add_vec procedure , pass ( a ), private :: vec_minus_vec end type vector","tags":"","loc":"type/vector.html"},{"title":"optical_properties – gridMCRT ","text":"type, public :: optical_properties Stores the optical properties of the medium. Currently only 1 media type. Can expand by making these arrays. Contents Variables albedo g2 hgg kappa mua mus Source Code optical_properties Components Type Visibility Attributes Name Initial real, public :: albedo The albedo is real, public :: g2 Is the g factor squared real, public :: hgg hgg is the g factor. Describes the bias of the scattering direction. 1 means forward, 0 isotropic and -1 backscattering. unitless real, public :: kappa is + real, public :: mua is the absorption coefficent. in cm real, public :: mus is the scattering coefficent. in cm Source Code type :: optical_properties !> \\mu_s is the scattering coefficent. in cm&#94;{-1} real :: mus !> \\mu_a is the absorption coefficent. in cm&#94;{-1} real :: mua !> hgg is the g factor. Describes the bias of the scattering direction. 1 means forward, 0 isotropic and -1 backscattering. unitless real :: hgg !> Is the g factor squared real :: g2 !> \\kappa is \\mu_s + \\mu_a real :: kappa !> The albedo is \\frac{\\mu_s}{\\mu_a+\\mu_s} real :: albedo end type optical_properties","tags":"","loc":"type/optical_properties.html"},{"title":"writer – gridMCRT","text":"public  subroutine writer(grid, nphotons) Uses constants gridset_mod proc~~writer~~UsesGraph proc~writer writer module~constants constants proc~writer->module~constants module~gridset_mod gridset_mod proc~writer->module~gridset_mod module~vector_class vector_class module~gridset_mod->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. subroutine to write out normalised fluence Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(in) :: grid grid integer, intent(in) :: nphotons number of photons to normalise by Called by proc~~writer~~CalledByGraph proc~writer writer program~mcpolar mcpolar program~mcpolar->proc~writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code writer Source Code subroutine writer ( grid , nphotons ) !! subroutine to write out normalised fluence use constants , only : fileplace use gridset_mod , only : cart_grid !> grid type ( cart_grid ), intent ( in ) :: grid !> number of photons to normalise by integer , intent ( in ) :: nphotons ! normalise fluence assuming power is 1W ! write out fluence end subroutine writer","tags":"","loc":"proc/writer.html"},{"title":"scatter – gridMCRT","text":"public  subroutine scatter(this, opt_prop) Uses constants random_mod optical_properties_class proc~~scatter~~UsesGraph proc~scatter scatter module~constants constants proc~scatter->module~constants module~optical_properties_class optical_properties_class proc~scatter->module~optical_properties_class module~random_mod random_mod proc~scatter->module~random_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0)\nadapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html Arguments Type Intent Optional Attributes Name class( photon ) :: this photon packet type( optical_properties ), intent(in) :: opt_prop optical properties Calls proc~~scatter~~CallsGraph proc~scatter scatter proc~ran2 ran2 proc~scatter->proc~ran2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code scatter Source Code subroutine scatter ( this , opt_prop ) !! photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0) !! adapted from mcxyz [https://omlc.org/software/mc/mcxyz/index.html](https://omlc.org/software/mc/mcxyz/index.html) use optical_properties_class , only : optical_properties use constants , only : PI , TWOPI use random_mod , only : ran2 !> photon packet class ( photon ) :: this !> optical properties type ( optical_properties ), intent ( in ) :: opt_prop real :: temp , uxx , uyy , uzz if ( opt_prop % hgg == 0.0 ) then !isotropic scattering this % cost = 2. * ran2 () - 1. else !henyey-greenstein scattering temp = ( 1.0 - opt_prop % g2 ) / ( 1.0 - opt_prop % hgg + 2. * opt_prop % hgg * ran2 ()) this % cost = ( 1.0 + opt_prop % g2 - temp ** 2 ) / ( 2. * opt_prop % hgg ) end if this % sint = sqrt ( 1. - this % cost ** 2 ) this % phi = TWOPI * ran2 () this % cosp = cos ( this % phi ) if ( this % phi < PI ) then this % sinp = sqrt ( 1. - this % cosp ** 2 ) else this % sinp = - sqrt ( 1. - this % cosp ** 2 ) end if if ( 1. - abs ( this % dir % z ) <= 1e-12 ) then ! near perpindicular uxx = this % sint * this % cosp uyy = this % sint * this % sinp uzz = sign ( this % cost , this % dir % z ) else temp = sqrt ( 1. - this % dir % z ** 2 ) uxx = this % sint * ( this % dir % x * this % dir % z * this % cosp - this % dir % y * this % sinp ) & / temp + this % dir % x * this % cost uyy = this % sint * ( this % dir % y * this % dir % z * this % cosp + this % dir % x * this % sinp ) & / temp + this % dir % y * this % cost uzz = - 1. * this % sint * this % cosp * temp + this % dir % z * this % cost end if this % dir % x = uxx this % dir % y = uyy this % dir % z = uzz end subroutine scatter","tags":"","loc":"proc/scatter.html"},{"title":"alloc_array – gridMCRT","text":"private  subroutine alloc_array(grid) Uses iarray proc~~alloc_array~~UsesGraph proc~alloc_array alloc_array module~iarray iarray proc~alloc_array->module~iarray Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. allocates allocatable 3D arrays Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(inout) :: grid Called by proc~~alloc_array~~CalledByGraph proc~alloc_array alloc_array proc~gridset gridset proc~gridset->proc~alloc_array program~mcpolar mcpolar program~mcpolar->proc~gridset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code alloc_array Source Code subroutine alloc_array ( grid ) !!  allocates allocatable 3D arrays use iarray , only : rhokap type ( cart_grid ), intent ( inout ) :: grid allocate ( rhokap ( grid % nxg , grid % nyg , grid % nzg )) allocate ( grid % xface ( grid % nxg + 1 )) allocate ( grid % yface ( grid % nyg + 1 )) allocate ( grid % zface ( grid % nzg + 1 )) end subroutine alloc_array","tags":"","loc":"proc/alloc_array.html"},{"title":"gridset – gridMCRT","text":"public  subroutine gridset(grid, opt_prop, nxg, nyg, nzg, xmax, ymax, zmax) Uses optical_properties_class iarray proc~~gridset~~UsesGraph proc~gridset gridset module~iarray iarray proc~gridset->module~iarray module~optical_properties_class optical_properties_class proc~gridset->module~optical_properties_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Set up grids and create geometry Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(out) :: grid grid variable that is assigned in this routine type( optical_properties ), intent(in) :: opt_prop optical properties used to setup voxel geometry integer, intent(in) :: nxg number of voxels in each dimension integer, intent(in) :: nyg number of voxels in each dimension integer, intent(in) :: nzg number of voxels in each dimension real, intent(in) :: xmax half size of the grid in cm real, intent(in) :: ymax half size of the grid in cm real, intent(in) :: zmax half size of the grid in cm Calls proc~~gridset~~CallsGraph proc~gridset gridset proc~alloc_array alloc_array proc~gridset->proc~alloc_array proc~zarray zarray proc~gridset->proc~zarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~gridset~~CalledByGraph proc~gridset gridset program~mcpolar mcpolar program~mcpolar->proc~gridset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code gridset Source Code subroutine gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) !! Set up grids and create geometry use iarray , only : rhokap , rhokap use optical_properties_class , only : optical_properties !> grid variable that is assigned in this routine type ( cart_grid ), intent ( out ) :: grid !> optical properties used to setup voxel geometry type ( optical_properties ), intent ( in ) :: opt_prop !> number of voxels in each dimension integer , intent ( in ) :: nxg , nyg , nzg !> half size of the grid in cm real , intent ( in ) :: xmax , ymax , zmax !> loop variables integer :: i , j , k !> temp variables real :: x , y , z , taueq1 , taupole1 , taueq2 , taupole2 print * , ' ' print * , 'Setting up grid....' ! set grid dimensions and voxel numbers grid % dim = vector ( xmax , ymax , zmax ) grid % nxg = nxg grid % nyg = nyg grid % nzg = nzg ! Set small distance for use in optical depth integration routines ! for roundoff effects when crossing cell walls grid % delta = 1.e-8 * ( 2. * grid % dim % z / grid % nzg ) ! allocate and set arrays to 0 call alloc_array ( grid ) call zarray ( grid ) ! setup grid cell walls do i = 1 , grid % nxg + 1 grid % xface ( i ) = ( i - 1 ) * 2. * grid % dim % x / grid % nxg end do do i = 1 , grid % nyg + 1 grid % yface ( i ) = ( i - 1 ) * 2. * grid % dim % y / grid % nyg end do do i = 1 , grid % nzg + 1 grid % zface ( i ) = ( i - 1 ) * 2. * grid % dim % z / grid % nzg end do !set up optical properties grid do i = 1 , grid % nxg x = grid % xface ( i ) - grid % dim % x + grid % dim % x / grid % nxg do j = 1 , grid % nyg y = grid % yface ( j ) - grid % dim % y + grid % dim % y / grid % nyg do k = 1 , grid % nzg z = grid % zface ( k ) - grid % dim % z + grid % dim % z / grid % nzg ! create a sphere of radius 1. if ( sqrt ( x ** 2 + y ** 2 + z ** 2 ) <= 1. ) then rhokap ( i , j , k ) = opt_prop % kappa else rhokap ( i , j , k ) = 0. end if end do end do end do ! Calculate equatorial and polar optical depths taueq1 = 0. taupole1 = 0. taueq2 = 0. taupole2 = 0. do i = 1 , grid % nxg taueq1 = taueq1 + rhokap ( i , grid % nyg / 2 , grid % nzg / 2 ) end do do i = 1 , grid % nzg taupole1 = taupole1 + rhokap ( grid % nxg / 2 , grid % nyg / 2 , i ) end do taueq1 = taueq1 * 2. * grid % dim % x / grid % nxg taupole1 = taupole1 * 2. * grid % dim % z / grid % nzg print '(A,F9.5,A,F9.5)' , ' taueq1 = ' , taueq1 , '  taupole1 = ' , taupole1 end subroutine gridset","tags":"","loc":"proc/gridset.html"},{"title":"zarray – gridMCRT","text":"private  subroutine zarray(grid) Uses iarray proc~~zarray~~UsesGraph proc~zarray zarray module~iarray iarray proc~zarray->module~iarray Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. set all 3D arrays to zero Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(inout) :: grid Called by proc~~zarray~~CalledByGraph proc~zarray zarray proc~gridset gridset proc~gridset->proc~zarray program~mcpolar mcpolar program~mcpolar->proc~gridset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code zarray Source Code subroutine zarray ( grid ) !! set all 3D arrays to zero use iarray , only : rhokap type ( cart_grid ), intent ( inout ) :: grid rhokap = 0. grid % xface = 0. grid % yface = 0. grid % zface = 0. end subroutine zarray","tags":"","loc":"proc/zarray.html"},{"title":"str_I32 – gridMCRT","text":"private  function str_I32(i) Uses iso_fortran_env proc~~str_i32~~UsesGraph proc~str_i32 str_I32 iso_fortran_env iso_fortran_env proc~str_i32->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. convert an int32 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable Called by proc~~str_i32~~CalledByGraph proc~str_i32 str_I32 interface~str str interface~str->proc~str_i32 program~mcpolar mcpolar program~mcpolar->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code str_I32 Source Code function str_I32 ( i ) !! convert an int32 integer into a string use iso_fortran_env , only : Int32 !> input int to convert into string integer ( int32 ), intent ( IN ) :: i character ( len = :), allocatable :: str_I32 character ( len = 100 ) :: string write ( string , '(I100.1)' ) I str_I32 = trim ( adjustl ( string )) end function str_I32","tags":"","loc":"proc/str_i32.html"},{"title":"str_I64 – gridMCRT","text":"private  function str_I64(i) Uses iso_fortran_env proc~~str_i64~~UsesGraph proc~str_i64 str_I64 iso_fortran_env iso_fortran_env proc~str_i64->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. convert an int64 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable Called by proc~~str_i64~~CalledByGraph proc~str_i64 str_I64 interface~str str interface~str->proc~str_i64 program~mcpolar mcpolar program~mcpolar->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code str_I64 Source Code function str_I64 ( i ) !! convert an int64 integer into a string use iso_fortran_env , only : Int64 !> input int to convert into string integer ( Int64 ), intent ( IN ) :: i character ( len = :), allocatable :: str_I64 character ( len = 100 ) :: string write ( string , '(I100.1)' ) I str_I64 = trim ( adjustl ( string )) end function str_I64","tags":"","loc":"proc/str_i64.html"},{"title":"str_R8 – gridMCRT","text":"private  function str_R8(i) convert an double precision float into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: i input float to convert into string Return Value character(len=:), allocatable Called by proc~~str_r8~~CalledByGraph proc~str_r8 str_R8 interface~str str interface~str->proc~str_r8 program~mcpolar mcpolar program~mcpolar->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code str_R8 Source Code function str_R8 ( i ) !! convert an double precision float into a string !> input float to convert into string double precision , intent ( IN ) :: i character ( len = :), allocatable :: str_R8 character ( len = 100 ) :: string write ( string , '(f100.16)' ) I str_R8 = trim ( adjustl ( string )) end function str_r8","tags":"","loc":"proc/str_r8.html"},{"title":"str_R8array – gridMCRT","text":"private  function str_R8array(a) convert an double precision float array into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (:) input float array to convert into string Return Value character(len=:), allocatable Called by proc~~str_r8array~~CalledByGraph proc~str_r8array str_R8array interface~str str interface~str->proc~str_r8array program~mcpolar mcpolar program~mcpolar->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code str_R8array Source Code function str_R8array ( a ) !! convert an double precision float array into a string !> input float array to convert into string double precision , intent ( IN ) :: a (:) character ( len = :), allocatable :: str_R8array character ( len = 100 ) :: string integer :: i do i = 1 , size ( a ) write ( string , '(f100.16)' ) a ( i ) str_R8array = str_R8array // ' ' // trim ( adjustl ( string )) end do end function str_R8array","tags":"","loc":"proc/str_r8array.html"},{"title":"str_iarray – gridMCRT","text":"private  function str_iarray(i) convert an int32 integer array into a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) input int array to convert into string Return Value character(len=:), allocatable Called by proc~~str_iarray~~CalledByGraph proc~str_iarray str_iarray interface~str str interface~str->proc~str_iarray program~mcpolar mcpolar program~mcpolar->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code str_iarray Source Code function str_iarray ( i ) !! convert an int32 integer array into a string !> input int array to convert into string integer , intent ( IN ) :: i (:) character ( len = :), allocatable :: str_iarray character ( len = 100 ) :: string integer :: j do j = 1 , size ( i ) write ( string , '(I100.1)' ) I ( j ) str_iarray = str_iarray // ' ' // trim ( adjustl ( string )) end do end function str_iarray","tags":"","loc":"proc/str_iarray.html"},{"title":"str_logicalarray – gridMCRT","text":"private  function str_logicalarray(a) convert an logical array into a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: a (:) input logical array to convert into string Return Value character(len=:), allocatable Called by proc~~str_logicalarray~~CalledByGraph proc~str_logicalarray str_logicalarray interface~str str interface~str->proc~str_logicalarray program~mcpolar mcpolar program~mcpolar->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code str_logicalarray Source Code function str_logicalarray ( a ) !! convert an logical array into a string !> input logical array to convert into string logical , intent ( IN ) :: a (:) character ( len = :), allocatable :: str_logicalarray character ( len = 100 ) :: string integer :: i do i = 1 , size ( a ) write ( string , '(L1)' ) a ( i ) str_logicalarray = str_logicalarray // ' ' // trim ( adjustl ( string )) end do end function str_logicalarray","tags":"","loc":"proc/str_logicalarray.html"},{"title":"set_directories – gridMCRT","text":"public  subroutine set_directories() Uses constants proc~~set_directories~~UsesGraph proc~set_directories set_directories module~constants constants proc~set_directories->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. define variables to hold paths to various folders Arguments None Called by proc~~set_directories~~CalledByGraph proc~set_directories set_directories program~mcpolar mcpolar program~mcpolar->proc~set_directories Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code set_directories Source Code subroutine set_directories () !! define variables to hold paths to various folders use constants , only : homedir , fileplace , resdir character ( len = 255 ) :: cwd !get current working directory call get_environment_variable ( 'PWD' , cwd ) ! get 'home' dir from cwd if ( index ( cwd , \"bin\" ) > 0 ) then ! if program is run from bin dir homedir = trim ( cwd ( 1 : len ( trim ( cwd )) - 3 )) else ! program is run from root dir homedir = trim ( cwd ) // \"/\" end if ! get data dir fileplace = trim ( homedir ) // 'data/' ! get res dir resdir = trim ( homedir ) // 'res/' end subroutine set_directories","tags":"","loc":"proc/set_directories.html"},{"title":"str – gridMCRT","text":"public interface str functions to turn numerical variables into strings Calls interface~~str~~CallsGraph interface~str str proc~str_i32 str_I32 interface~str->proc~str_i32 proc~str_i64 str_I64 interface~str->proc~str_i64 proc~str_iarray str_iarray interface~str->proc~str_iarray proc~str_logicalarray str_logicalarray interface~str->proc~str_logicalarray proc~str_r8 str_R8 interface~str->proc~str_r8 proc~str_r8array str_R8array interface~str->proc~str_r8array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~str~~CalledByGraph interface~str str program~mcpolar mcpolar program~mcpolar->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures str_I32 str_I64 str_Iarray str_R8 str_R8array str_logicalarray Module Procedures private  function str_I32 (i) convert an int32 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_I64 (i) convert an int64 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_iarray (i) convert an int32 integer array into a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) input int array to convert into string Return Value character(len=:), allocatable private  function str_R8 (i) convert an double precision float into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: i input float to convert into string Return Value character(len=:), allocatable private  function str_R8array (a) convert an double precision float array into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (:) input float array to convert into string Return Value character(len=:), allocatable private  function str_logicalarray (a) convert an logical array into a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: a (:) input logical array to convert into string Return Value character(len=:), allocatable","tags":"","loc":"interface/str.html"},{"title":"magnitude_fn – gridMCRT","text":"private pure function magnitude_fn(this) implmentation of |vector| Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: this Return Value type( vector ) Contents Source Code magnitude_fn Source Code pure type ( vector ) function magnitude_fn ( this ) !! implmentation of |vector| class ( vector ), intent ( in ) :: this real :: tmp tmp = sqrt ( this % x ** 2 + this % y ** 2 + this % z ** 2 ) magnitude_fn = this / tmp end function magnitude_fn","tags":"","loc":"proc/magnitude_fn.html"},{"title":"scal_add_vec – gridMCRT","text":"private pure function scal_add_vec(a, b) implmentation of scalar subtract vector\noverloads the + operator Arguments Type Intent Optional Attributes Name real, intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) Contents Source Code scal_add_vec Source Code pure type ( vector ) function scal_add_vec ( a , b ) !! implmentation of scalar subtract vector !! overloads the + operator class ( vector ), intent ( IN ) :: b real , intent ( IN ) :: a scal_add_vec = vector ( b % x + a , b % y + a , b % z + a ) end function scal_add_vec","tags":"","loc":"proc/scal_add_vec.html"},{"title":"scal_mult_vec – gridMCRT","text":"private pure function scal_mult_vec(a, b) implmentation of scalar multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name real, intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) Contents Source Code scal_mult_vec Source Code pure type ( vector ) function scal_mult_vec ( a , b ) !! implmentation of scalar multiply vector !! overloads the * operator class ( vector ), intent ( IN ) :: b real , intent ( IN ) :: a scal_mult_vec = vector ( a * b % x , a * b % y , a * b % z ) end function scal_mult_vec","tags":"","loc":"proc/scal_mult_vec.html"},{"title":"vec_add_scal – gridMCRT","text":"private pure function vec_add_scal(a, b) implmentation of vector add scalar\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) Contents Source Code vec_add_scal Source Code pure type ( vector ) function vec_add_scal ( a , b ) !! implmentation of vector add scalar !! overloads the + operator class ( vector ), intent ( IN ) :: a real , intent ( IN ) :: b vec_add_scal = vector ( a % x + b , a % y + b , a % z + b ) end function vec_add_scal","tags":"","loc":"proc/vec_add_scal.html"},{"title":"vec_add_vec – gridMCRT","text":"private pure function vec_add_vec(a, b) implmentation of vector add vector\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) Contents Source Code vec_add_vec Source Code pure type ( vector ) function vec_add_vec ( a , b ) !! implmentation of vector add vector !! overloads the + operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_add_vec = vector ( a % x + b % x , a % y + b % y , a % z + b % z ) end function vec_add_vec","tags":"","loc":"proc/vec_add_vec.html"},{"title":"vec_div_scal – gridMCRT","text":"private pure function vec_div_scal(a, b) implmentation of vector divide scalar\noverloads the / operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) Contents Source Code vec_div_scal Source Code pure type ( vector ) function vec_div_scal ( a , b ) !! implmentation of vector divide scalar !! overloads the / operator class ( vector ), intent ( IN ) :: a real , intent ( IN ) :: b vec_div_scal = vector ( a % x / b , a % y / b , a % z / b ) end function vec_div_scal","tags":"","loc":"proc/vec_div_scal.html"},{"title":"vec_dot – gridMCRT","text":"private pure elemental function vec_dot(a, b) result(dot) implmentation of vector dot vector\ncreates the .dot. operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value real Contents Source Code vec_dot Source Code pure elemental function vec_dot ( a , b ) result ( dot ) !! implmentation of vector dot vector !! creates the .dot. operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b real :: dot dot = ( a % x * b % x ) + ( a % y * b % y ) + ( a % z * b % z ) end function vec_dot","tags":"","loc":"proc/vec_dot.html"},{"title":"vec_minus_vec – gridMCRT","text":"private pure function vec_minus_vec(a, b) implmentation of vector subtract vector\noverloads the - operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) Contents Source Code vec_minus_vec Source Code pure type ( vector ) function vec_minus_vec ( a , b ) !! implmentation of vector subtract vector !! overloads the - operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_minus_vec = vector ( a % x - b % x , a % y - b % y , a % z - b % z ) end function vec_minus_vec","tags":"","loc":"proc/vec_minus_vec.html"},{"title":"vec_mult_scal – gridMCRT","text":"private pure function vec_mult_scal(a, b) implmentation of vector multiply scalar\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) Contents Source Code vec_mult_scal Source Code pure type ( vector ) function vec_mult_scal ( a , b ) !! implmentation of vector multiply scalar !! overloads the * operator class ( vector ), intent ( IN ) :: a real , intent ( IN ) :: b vec_mult_scal = vector ( a % x * b , a % y * b , a % z * b ) end function vec_mult_scal","tags":"","loc":"proc/vec_mult_scal.html"},{"title":"vec_mult_vec – gridMCRT","text":"private pure function vec_mult_vec(a, b) implmentation of vector multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) Contents Source Code vec_mult_vec Source Code pure type ( vector ) function vec_mult_vec ( a , b ) !! implmentation of vector multiply vector !! overloads the * operator !@note !    This is ELEMENT wise multiplication !@end note class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_mult_vec = vector ( a % x * b % x , a % y * b % y , a % z * b % z ) end function vec_mult_vec","tags":"","loc":"proc/vec_mult_vec.html"},{"title":"print_sub – gridMCRT","text":"private  subroutine print_sub(this) prints the vector Arguments Type Intent Optional Attributes Name class( vector ) :: this Contents Source Code print_sub Source Code subroutine print_sub ( this ) !! prints the vector class ( vector ) :: this print * , this % x , this % y , this % z end subroutine print_sub","tags":"","loc":"proc/print_sub.html"},{"title":"ran2 – gridMCRT","text":"public  function ran2() Wrapper function to fortran internal random number generator\nGenerates a random number in the range [0,1.) Arguments None Return Value real Called by proc~~ran2~~CalledByGraph proc~ran2 ran2 proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->proc~ran2 proc~ranu ranu proc~ranu->proc~ran2 proc~scatter scatter proc~scatter->proc~ran2 proc~tauint1 tauint1 proc~tauint1->proc~ran2 program~mcpolar mcpolar program~mcpolar->proc~ran2 program~mcpolar->proc~isotropic_point_src program~mcpolar->proc~tauint1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code ran2 Source Code real function ran2 () !! Wrapper function to fortran internal random number generator !! Generates a random number in the range [0,1.) call random_number ( ran2 ) end function ran2","tags":"","loc":"proc/ran2.html"},{"title":"ranu – gridMCRT","text":"public  function ranu(a, b) sample uniformly between [a, b] Arguments Type Intent Optional Attributes Name real, intent(in) :: a input lower bound real, intent(in) :: b input upper bound Return Value real Calls proc~~ranu~~CallsGraph proc~ranu ranu proc~ran2 ran2 proc~ranu->proc~ran2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code ranu Source Code real function ranu ( a , b ) !! sample uniformly between [a, b] !> input lower bound real , intent ( in ) :: a !> input upper bound real , intent ( in ) :: b ranu = a + ran2 () * ( b - a ) end function ranu","tags":"","loc":"proc/ranu.html"},{"title":"init_seed – gridMCRT","text":"public  subroutine init_seed(seed) user convenience function for setting random generator seed Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed user defined seed Called by proc~~init_seed~~CalledByGraph proc~init_seed init_seed program~mcpolar mcpolar program~mcpolar->proc~init_seed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code init_seed Source Code subroutine init_seed ( seed ) !! user convenience function for setting random generator seed !> user defined seed integer , intent ( in ) :: seed !> size of internal seed array integer :: n !> internal seed array to be filled with user defined seed integer , allocatable :: iseed (:) ! get seed size call random_seed ( size = n ) allocate ( iseed ( n )) ! put user seed in actual seed iseed = seed ! seed the RNG call random_seed ( put = iseed ) end subroutine init_seed","tags":"","loc":"proc/init_seed.html"},{"title":"wall_dist – gridMCRT","text":"private  function wall_dist(packet, grid, celli, cellj, cellk, pos, dir) Uses gridset_mod photon_class vector_class proc~~wall_dist~~UsesGraph proc~wall_dist wall_dist module~gridset_mod gridset_mod proc~wall_dist->module~gridset_mod module~photon_class photon_class proc~wall_dist->module~photon_class module~vector_class vector_class proc~wall_dist->module~vector_class module~gridset_mod->module~vector_class module~photon_class->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. function that returns distant to nearest wall and which wall that is (x ,y or z) Arguments Type Intent Optional Attributes Name type( photon ), intent(inout) :: packet photon packet type( cart_grid ), intent(in) :: grid grid variable container integer, intent(inout) :: celli current voxel ID integer, intent(inout) :: cellj current voxel ID integer, intent(inout) :: cellk current voxel ID type( vector ), intent(inout) :: pos current position logical, intent(inout) :: dir (:) which wall will we hit. Stored as array of bools Return Value real Called by proc~~wall_dist~~CalledByGraph proc~wall_dist wall_dist proc~tauint1 tauint1 proc~tauint1->proc~wall_dist program~mcpolar mcpolar program~mcpolar->proc~tauint1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code wall_dist Source Code real function wall_dist ( packet , grid , celli , cellj , cellk , pos , dir ) !!function that returns distant to nearest wall and which wall that is (x ,y or z) use gridset_mod , only : cart_grid use photon_class , only : photon use vector_class , only : vector !> photon packet type ( photon ), intent ( inout ) :: packet !> grid variable container type ( cart_grid ), intent ( in ) :: grid !> current position type ( vector ), intent ( inout ) :: pos !> which wall will we hit. Stored as array of bools logical , intent ( inout ) :: dir (:) !> current voxel ID integer , intent ( inout ) :: celli , cellj , cellk real :: dx , dy , dz ! get distance to a wall in the x direction if ( packet % dir % x > 0. ) then dx = ( grid % xface ( celli + 1 ) - pos % x ) / packet % dir % x elseif ( packet % dir % x < 0. ) then dx = ( grid % xface ( celli ) - pos % x ) / packet % dir % x elseif ( packet % dir % x == 0. ) then dx = 10000 0. end if ! get distance to a wall in the y direction if ( packet % dir % y > 0. ) then dy = ( grid % yface ( cellj + 1 ) - pos % y ) / packet % dir % y elseif ( packet % dir % y < 0. ) then dy = ( grid % yface ( cellj ) - pos % y ) / packet % dir % y elseif ( packet % dir % y == 0. ) then dy = 10000 0. end if ! get distance to a wall in the z direction if ( packet % dir % z > 0. ) then dz = ( grid % zface ( cellk + 1 ) - pos % z ) / packet % dir % z elseif ( packet % dir % z < 0. ) then dz = ( grid % zface ( cellk ) - pos % z ) / packet % dir % z elseif ( packet % dir % z == 0. ) then dz = 10000 0. end if !get closest wall wall_dist = min ( dx , dy , dz ) if ( wall_dist < 0. ) print '(A,7F9.5)' , 'dcell < 0.0 warning! ' , wall_dist , dx , dy , dz , packet % dir if ( wall_dist == dx ) dir = ( / . TRUE ., . FALSE ., . FALSE . / ) if ( wall_dist == dy ) dir = ( / . FALSE ., . TRUE ., . FALSE . / ) if ( wall_dist == dz ) dir = ( / . FALSE ., . FALSE ., . TRUE . / ) if (. not . dir ( 1 ) . and . . not . dir ( 2 ) . and . . not . dir ( 3 )) print * , 'Error in dir flag' end function wall_dist","tags":"","loc":"proc/wall_dist.html"},{"title":"tauint1 – gridMCRT","text":"public  subroutine tauint1(packet, grid) Uses photon_class gridset_mod iarray vector_class random_mod proc~~tauint1~~UsesGraph proc~tauint1 tauint1 module~gridset_mod gridset_mod proc~tauint1->module~gridset_mod module~iarray iarray proc~tauint1->module~iarray module~photon_class photon_class proc~tauint1->module~photon_class module~random_mod random_mod proc~tauint1->module~random_mod module~vector_class vector_class proc~tauint1->module~vector_class module~gridset_mod->module~vector_class module~photon_class->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. optical depth integration subroutine. The main workhorse of MCRT Arguments Type Intent Optional Attributes Name type( photon ), intent(inout) :: packet packet to move through the grid type( cart_grid ), intent(in) :: grid grid that the packet moves through Calls proc~~tauint1~~CallsGraph proc~tauint1 tauint1 proc~ran2 ran2 proc~tauint1->proc~ran2 proc~update_pos update_pos proc~tauint1->proc~update_pos proc~wall_dist wall_dist proc~tauint1->proc~wall_dist proc~update_voxels update_voxels proc~update_pos->proc~update_voxels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~tauint1~~CalledByGraph proc~tauint1 tauint1 program~mcpolar mcpolar program~mcpolar->proc~tauint1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code tauint1 Source Code subroutine tauint1 ( packet , grid ) !! optical depth integration subroutine. The main workhorse of MCRT use gridset_mod , only : cart_grid use iarray , only : rhokap use photon_class , only : photon use random_mod , only : ran2 use vector_class , only : vector !> packet to move through the grid type ( photon ), intent ( inout ) :: packet !> grid that the packet moves through type ( cart_grid ), intent ( in ) :: grid ! intermediate position type ( vector ) :: pos real :: tau , taurun , taucell , d , dcell integer :: celli , cellj , cellk logical :: dir ( 3 ) !change grid origin to lower left of the grid pos = packet % pos + grid % dim ! store current voxel in temp variables celli = packet % xcell cellj = packet % ycell cellk = packet % zcell ! setup to start integrating taurun = 0. d = 0. dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !sample optical distance tau = - log ( ran2 ()) do dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !get distance to nearest wall in direction dir dcell = wall_dist ( packet , grid , celli , cellj , cellk , pos , dir ) !calculate optical distnace to cell wall taucell = dcell * rhokap ( celli , cellj , cellk ) if ( taurun + taucell < tau ) then !still some tau to move taurun = taurun + taucell d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . TRUE ., dir ) else !moved full distance dcell = ( tau - taurun ) / rhokap ( celli , cellj , cellk ) d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . FALSE ., dir ) exit end if if ( celli == - 1 . or . cellj == - 1 . or . cellk == - 1 ) then packet % tflag = . true . exit end if end do ! move back to grid with origin at the centre packet % pos = pos - grid % dim packet % xcell = celli packet % ycell = cellj packet % zcell = cellk end subroutine tauint1","tags":"","loc":"proc/tauint1.html"},{"title":"update_pos – gridMCRT","text":"private pure subroutine update_pos(packet, grid, pos, celli, cellj, cellk, dcell, wall_flag, dir) Uses photon_class gridset_mod vector_class utils random_mod proc~~update_pos~~UsesGraph proc~update_pos update_pos module~gridset_mod gridset_mod proc~update_pos->module~gridset_mod module~photon_class photon_class proc~update_pos->module~photon_class module~random_mod random_mod proc~update_pos->module~random_mod module~utils utils proc~update_pos->module~utils module~vector_class vector_class proc~update_pos->module~vector_class module~gridset_mod->module~vector_class module~photon_class->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. routine that upates postions of photon and calls fresnel routines if photon leaves current voxel Arguments Type Intent Optional Attributes Name type( photon ), intent(in) :: packet photon object type( cart_grid ), intent(in) :: grid grid object type( vector ), intent(inout) :: pos current photon position integer, intent(inout) :: celli current voxel ID integer, intent(inout) :: cellj current voxel ID integer, intent(inout) :: cellk current voxel ID real, intent(in) :: dcell distance phton will travel across a cell logical, intent(in) :: wall_flag flag is true if we hit a cell wall logical, intent(in) :: dir (:) logical array. 1 entry is always true. the true entry represents which cell wall we will hit Calls proc~~update_pos~~CallsGraph proc~update_pos update_pos proc~update_voxels update_voxels proc~update_pos->proc~update_voxels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~update_pos~~CalledByGraph proc~update_pos update_pos proc~tauint1 tauint1 proc~tauint1->proc~update_pos program~mcpolar mcpolar program~mcpolar->proc~tauint1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code update_pos Source Code pure subroutine update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , wall_flag , dir ) !! routine that upates postions of photon and calls fresnel routines if photon leaves current voxel use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 use utils , only : str use vector_class , only : vector !> photon object type ( photon ), intent ( in ) :: packet !> current photon position type ( vector ), intent ( inout ) :: pos !> grid object type ( cart_grid ), intent ( in ) :: grid !> distance phton will travel across a cell real , intent ( in ) :: dcell !> current voxel ID integer , intent ( inout ) :: celli , cellj , cellk !> flag is true if we hit a cell wall logical , intent ( in ) :: wall_flag !> logical array. 1 entry is always true. the true entry represents which cell wall we will hit logical , intent ( in ) :: dir (:) ! if we hit a wall if ( wall_flag ) then ! in the x direction if ( dir ( 1 )) then if ( packet % dir % x > 0. ) then pos % x = grid % xface ( celli + 1 ) + grid % delta celli = celli + 1 elseif ( packet % dir % x < 0. ) then pos % x = grid % xface ( celli ) - grid % delta celli = celli - 1 else error stop 'Error in x dir in update_pos' end if pos % y = pos % y + packet % dir % y * dcell pos % z = pos % z + packet % dir % z * dcell ! y direction elseif ( dir ( 2 )) then if ( packet % dir % y > 0. ) then pos % y = grid % yface ( cellj + 1 ) + grid % delta cellj = cellj + 1 elseif ( packet % dir % y < 0. ) then pos % y = grid % yface ( cellj ) - grid % delta cellj = cellj - 1 else error stop 'Error in y dir in update_pos' end if pos % x = pos % x + packet % dir % x * dcell pos % z = pos % z + packet % dir % z * dcell ! z direction elseif ( dir ( 3 )) then if ( packet % dir % z > 0. ) then pos % z = grid % zface ( cellk + 1 ) + grid % delta cellk = cellk + 1 elseif ( packet % dir % z < 0. ) then pos % z = grid % zface ( cellk ) - grid % delta cellk = cellk - 1 else error stop 'Error in z dir in update_pos' end if pos % x = pos % x + packet % dir % x * dcell pos % y = pos % y + packet % dir % y * dcell else error stop 'Error in update_pos...' end if else ! we dont hit a wall pos = pos + packet % dir * dcell end if if ( wall_flag ) then ! if we hit a wall, get current voxel call update_voxels ( pos , grid , celli , cellj , cellk ) end if end subroutine update_pos","tags":"","loc":"proc/update_pos.html"},{"title":"update_voxels – gridMCRT","text":"private pure subroutine update_voxels(pos, grid, celli, cellj, cellk) Uses gridset_mod vector_class proc~~update_voxels~~UsesGraph proc~update_voxels update_voxels module~gridset_mod gridset_mod proc~update_voxels->module~gridset_mod module~vector_class vector_class proc~update_voxels->module~vector_class module~gridset_mod->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. updates the current voxel based upon position Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: pos current photon position vector type( cart_grid ), intent(in) :: grid grid object integer, intent(inout) :: celli current voxel ID. To be updated integer, intent(inout) :: cellj current voxel ID. To be updated integer, intent(inout) :: cellk current voxel ID. To be updated Called by proc~~update_voxels~~CalledByGraph proc~update_voxels update_voxels proc~update_pos update_pos proc~update_pos->proc~update_voxels proc~tauint1 tauint1 proc~tauint1->proc~update_pos program~mcpolar mcpolar program~mcpolar->proc~tauint1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code update_voxels Source Code pure subroutine update_voxels ( pos , grid , celli , cellj , cellk ) !! updates the current voxel based upon position use gridset_mod , only : cart_grid use vector_class , only : vector !> current photon position vector type ( vector ), intent ( in ) :: pos !> grid object type ( cart_grid ), intent ( in ) :: grid !> current voxel ID. To be updated integer , intent ( inout ) :: celli , cellj , cellk celli = floor ( grid % nxg * ( pos % x ) / ( 2. * grid % dim % x )) + 1 cellj = floor ( grid % nyg * ( pos % y ) / ( 2. * grid % dim % y )) + 1 cellk = floor ( grid % nzg * ( pos % z ) / ( 2. * grid % dim % z )) + 1 if ( celli > grid % nxg . or . celli < 1 ) celli = - 1 if ( cellj > grid % nyg . or . cellj < 1 ) cellj = - 1 if ( cellk > grid % nzg . or . cellk < 1 ) cellk = - 1 end subroutine update_voxels","tags":"","loc":"proc/update_voxels.html"},{"title":"isotropic_point_src – gridMCRT","text":"public  subroutine isotropic_point_src(packet, grid) Uses constants random_mod gridset_mod photon_class proc~~isotropic_point_src~~UsesGraph proc~isotropic_point_src isotropic_point_src module~constants constants proc~isotropic_point_src->module~constants module~gridset_mod gridset_mod proc~isotropic_point_src->module~gridset_mod module~photon_class photon_class proc~isotropic_point_src->module~photon_class module~random_mod random_mod proc~isotropic_point_src->module~random_mod module~vector_class vector_class module~gridset_mod->module~vector_class module~photon_class->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. set intial photon position at (0.0, 0.0, 0.0) and sample photon direction in an isotropic manner. Arguments Type Intent Optional Attributes Name type( photon ), intent(out) :: packet photon object type( cart_grid ), intent(in) :: grid grid object Calls proc~~isotropic_point_src~~CallsGraph proc~isotropic_point_src isotropic_point_src proc~ran2 ran2 proc~isotropic_point_src->proc~ran2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~isotropic_point_src~~CalledByGraph proc~isotropic_point_src isotropic_point_src program~mcpolar mcpolar program~mcpolar->proc~isotropic_point_src Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code isotropic_point_src Source Code subroutine isotropic_point_src ( packet , grid ) !! set intial photon position at (0.0, 0.0, 0.0) and sample photon direction in an isotropic manner. use constants , only : TWOPI use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 !> photon object type ( photon ), intent ( out ) :: packet !> grid object type ( cart_grid ), intent ( in ) :: grid !set packet position packet % pos % z = 0.0 packet % pos % x = 0.0 packet % pos % y = 0.0 ! set packet cosines packet % phi = ran2 () * twoPI packet % cosp = cos ( packet % phi ) packet % sinp = sin ( packet % phi ) packet % cost = 2. * ran2 () - 1. packet % sint = sqrt ( 1. - packet % cost ** 2 ) ! set direction vector packet % dir % x = packet % sint * packet % cosp packet % dir % y = packet % sint * packet % sinp packet % dir % z = packet % cost ! set packet voxel packet % xcell = int ( grid % nxg * ( packet % pos % x + grid % dim % x ) / ( 2. * grid % dim % x )) + 1 packet % ycell = int ( grid % nyg * ( packet % pos % y + grid % dim % y ) / ( 2. * grid % dim % y )) + 1 packet % zcell = int ( grid % nzg * ( packet % pos % z + grid % dim % z ) / ( 2. * grid % dim % z )) + 1 packet % tflag = . false . end subroutine isotropic_point_src","tags":"","loc":"proc/isotropic_point_src.html"},{"title":"init_opt2 – gridMCRT","text":"public  subroutine init_opt2(opt_prop) Set tissue optical properties 420nm Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop optical property container Contents Source Code init_opt2 Source Code subroutine init_opt2 ( opt_prop ) !!  Set tissue optical properties 420nm !> optical property container type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.9 opt_prop % g2 = opt_prop % hgg ** 2. opt_prop % mua = 1.8 opt_prop % mus = 8 2.0 / ( 1.0 - opt_prop % hgg ) opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt2","tags":"","loc":"proc/init_opt2.html"},{"title":"init_opt_sphere – gridMCRT","text":"public  subroutine init_opt_sphere(opt_prop) Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop optical property container Called by proc~~init_opt_sphere~~CalledByGraph proc~init_opt_sphere init_opt_sphere program~mcpolar mcpolar program~mcpolar->proc~init_opt_sphere Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code init_opt_sphere Source Code subroutine init_opt_sphere ( opt_prop ) !!  Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. !> optical property container type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.0d0 opt_prop % g2 = opt_prop % hgg ** 2. opt_prop % mua = 0.0 opt_prop % mus = 1 0.0 opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt_sphere","tags":"","loc":"proc/init_opt_sphere.html"},{"title":"iarray – gridMCRT","text":"Contains all array variable names. Used by module~~iarray~~UsedByGraph module~iarray iarray proc~alloc_array alloc_array proc~alloc_array->module~iarray proc~gridset gridset proc~gridset->module~iarray proc~tauint1 tauint1 proc~tauint1->module~iarray proc~zarray zarray proc~zarray->module~iarray Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables rhokap Variables Type Visibility Attributes Name Initial real, public, allocatable :: rhokap (:,:,:) stores the optical properties, i.e the total cross section","tags":"","loc":"module/iarray.html"},{"title":"writer_mod – gridMCRT","text":"I/O related routines. Used by module~~writer_mod~~UsedByGraph module~writer_mod writer_mod program~mcpolar mcpolar program~mcpolar->module~writer_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines writer Subroutines public  subroutine writer (grid, nphotons) subroutine to write out normalised fluence Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(in) :: grid grid integer, intent(in) :: nphotons number of photons to normalise by","tags":"","loc":"module/writer_mod.html"},{"title":"photon_class – gridMCRT","text":"Module defines the photon class and scattering routines Uses vector_class module~~photon_class~~UsesGraph module~photon_class photon_class module~vector_class vector_class module~photon_class->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~photon_class~~UsedByGraph module~photon_class photon_class proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->module~photon_class proc~tauint1 tauint1 proc~tauint1->module~photon_class proc~update_pos update_pos proc~update_pos->module~photon_class proc~wall_dist wall_dist proc~wall_dist->module~photon_class program~mcpolar mcpolar program~mcpolar->module~photon_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types photon Subroutines scatter Derived Types type, public :: photon photon type. Encapsulates all information about a single photon. Components Type Visibility Attributes Name Initial real, public :: cosp is the azimuthal angle in the physics spherical coordinate system real, public :: cost is the polar angle in the physics spherical coordinate system type( vector ), public :: dir direction vector real, public :: phi is the azimuthal angle in the physics spherical coordinate system type( vector ), public :: pos position vector real, public :: sinp is the azimuthal angle in the physics spherical coordinate system real, public :: sint . is the polar angle in the physics spherical coordinate system logical, public :: tflag Boolean flag that if true photon is alive and in the simulation integer, public :: xcell Current voxel which the photon is in integer, public :: ycell Current voxel which the photon is in integer, public :: zcell Current voxel which the photon is in Type-Bound Procedures procedure\n                    ,                  public\n                  :: scatter Subroutine Subroutines public  subroutine scatter (this, opt_prop) photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0)\nadapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html Arguments Type Intent Optional Attributes Name class( photon ) :: this photon packet type( optical_properties ), intent(in) :: opt_prop optical properties","tags":"","loc":"module/photon_class.html"},{"title":"gridset_mod – gridMCRT","text":"Module provides a cartesian grid type to store all grid related variables in a container\nAlso provides a way of setting up the geomerty/grid for the simulation. Uses vector_class module~~gridset_mod~~UsesGraph module~gridset_mod gridset_mod module~vector_class vector_class module~gridset_mod->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~gridset_mod~~UsedByGraph module~gridset_mod gridset_mod proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->module~gridset_mod proc~tauint1 tauint1 proc~tauint1->module~gridset_mod proc~update_pos update_pos proc~update_pos->module~gridset_mod proc~update_voxels update_voxels proc~update_voxels->module~gridset_mod proc~wall_dist wall_dist proc~wall_dist->module~gridset_mod proc~writer writer proc~writer->module~gridset_mod program~mcpolar mcpolar program~mcpolar->module~gridset_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types cart_grid Subroutines alloc_array gridset zarray Derived Types type, public :: cart_grid 3D cartesian grid. Stores information about the linear voxel grid Components Type Visibility Attributes Name Initial real, public :: delta ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls type( vector ), public :: dim half size of grid in each dimension. cm integer, public :: nxg Size of grid in voxels in each direction integer, public :: nyg Size of grid in voxels in each direction integer, public :: nzg Size of grid in voxels in each direction real, public, allocatable :: xface (:) Arrays that store the location of each grid cell(voxel) wall real, public, allocatable :: yface (:) Arrays that store the location of each grid cell(voxel) wall real, public, allocatable :: zface (:) Arrays that store the location of each grid cell(voxel) wall Subroutines private  subroutine alloc_array (grid) allocates allocatable 3D arrays Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(inout) :: grid public  subroutine gridset (grid, opt_prop, nxg, nyg, nzg, xmax, ymax, zmax) Set up grids and create geometry Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(out) :: grid grid variable that is assigned in this routine type( optical_properties ), intent(in) :: opt_prop optical properties used to setup voxel geometry integer, intent(in) :: nxg number of voxels in each dimension integer, intent(in) :: nyg number of voxels in each dimension integer, intent(in) :: nzg number of voxels in each dimension real, intent(in) :: xmax half size of the grid in cm real, intent(in) :: ymax half size of the grid in cm real, intent(in) :: zmax half size of the grid in cm private  subroutine zarray (grid) set all 3D arrays to zero Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(inout) :: grid","tags":"","loc":"module/gridset_mod.html"},{"title":"utils – gridMCRT","text":"module that contains utility functions and helper routines. Used by module~~utils~~UsedByGraph module~utils utils proc~update_pos update_pos proc~update_pos->module~utils program~mcpolar mcpolar program~mcpolar->module~utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces str Functions str_I32 str_I64 str_R8 str_R8array str_iarray str_logicalarray Subroutines set_directories Interfaces public        interface str functions to turn numerical variables into strings private  function str_I32 (i) convert an int32 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_I64 (i) convert an int64 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_iarray (i) convert an int32 integer array into a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) input int array to convert into string Return Value character(len=:), allocatable private  function str_R8 (i) convert an double precision float into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: i input float to convert into string Return Value character(len=:), allocatable private  function str_R8array (a) convert an double precision float array into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (:) input float array to convert into string Return Value character(len=:), allocatable private  function str_logicalarray (a) convert an logical array into a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: a (:) input logical array to convert into string Return Value character(len=:), allocatable Functions private  function str_I32 (i) convert an int32 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_I64 (i) convert an int64 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: i input int to convert into string Return Value character(len=:), allocatable private  function str_R8 (i) convert an double precision float into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: i input float to convert into string Return Value character(len=:), allocatable private  function str_R8array (a) convert an double precision float array into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (:) input float array to convert into string Return Value character(len=:), allocatable private  function str_iarray (i) convert an int32 integer array into a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) input int array to convert into string Return Value character(len=:), allocatable private  function str_logicalarray (a) convert an logical array into a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: a (:) input logical array to convert into string Return Value character(len=:), allocatable Subroutines public  subroutine set_directories () define variables to hold paths to various folders Arguments None","tags":"","loc":"module/utils.html"},{"title":"constants – gridMCRT","text":"Constants used throughout the simulation. Used by module~~constants~~UsedByGraph module~constants constants proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->module~constants proc~scatter scatter proc~scatter->module~constants proc~set_directories set_directories proc~set_directories->module~constants proc~writer writer proc~writer->module~constants program~mcpolar mcpolar program~mcpolar->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables PI TWOPI fileplace homedir resdir Variables Type Visibility Attributes Name Initial real, public, parameter :: PI = 4.*atan(1.) mathematical constants real, public, parameter :: TWOPI = 2.*PI mathematical constants character(len=255), public :: fileplace variables that stores the directory where output files are saved character(len=255), public :: homedir variables that stores the home (root) directory character(len=255), public :: resdir variables that stores the directory for input files.","tags":"","loc":"module/constants.html"},{"title":"vector_class – gridMCRT","text":"Module contains the vector class and associated routines. Used by module~~vector_class~~UsedByGraph module~vector_class vector_class module~gridset_mod gridset_mod module~gridset_mod->module~vector_class module~photon_class photon_class module~photon_class->module~vector_class proc~tauint1 tauint1 proc~tauint1->module~vector_class proc~tauint1->module~gridset_mod proc~tauint1->module~photon_class proc~update_pos update_pos proc~update_pos->module~vector_class proc~update_pos->module~gridset_mod proc~update_pos->module~photon_class proc~update_voxels update_voxels proc~update_voxels->module~vector_class proc~update_voxels->module~gridset_mod proc~wall_dist wall_dist proc~wall_dist->module~vector_class proc~wall_dist->module~gridset_mod proc~wall_dist->module~photon_class proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->module~gridset_mod proc~isotropic_point_src->module~photon_class proc~writer writer proc~writer->module~gridset_mod program~mcpolar mcpolar program~mcpolar->module~gridset_mod program~mcpolar->module~photon_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types vector Functions magnitude_fn scal_add_vec scal_mult_vec vec_add_scal vec_add_vec vec_div_scal vec_dot vec_minus_vec vec_mult_scal vec_mult_vec Subroutines print_sub Derived Types type, public :: vector Vector type used for direction and position vectors\nsupports all possible vector operations Components Type Visibility Attributes Name Initial real, public :: x components of the vector real, public :: y components of the vector real, public :: z components of the vector Type-Bound Procedures procedure\n                    ,                  public\n                  :: magnitude => magnitude_fn Function get the magnitde of a vector generic,\n                  public\n                  :: operator(*) => vec_mult_vec , vec_mult_scal , scal_mult_vec multiple a vector by a scalar or vector (element wise) generic,\n                  public\n                  :: operator(+) => vec_add_vec , vec_add_scal , scal_add_vec add two vectors, or a vector and a scalar generic,\n                  public\n                  :: operator(-) => vec_minus_vec subtract a vector from a vector generic,\n                  public\n                  :: operator(.dot.) => vec_dot get the dot product of two vectors generic,\n                  public\n                  :: operator(/) => vec_div_scal divide a vector by a float procedure\n                    ,                  public\n                  :: print => print_sub Subroutine print a vector procedure\n                    ,                  private\n, pass(b)                  :: scal_add_vec Function procedure\n                    ,                  private\n, pass(b)                  :: scal_mult_vec Function procedure\n                    ,                  private\n, pass(a)                  :: vec_add_scal Function procedure\n                    ,                  private\n, pass(a)                  :: vec_add_vec Function procedure\n                    ,                  private\n, pass(a)                  :: vec_div_scal Function procedure\n                    ,                  private\n, pass(a)                  :: vec_dot Function procedure\n                    ,                  private\n, pass(a)                  :: vec_minus_vec Function procedure\n                    ,                  private\n, pass(a)                  :: vec_mult_scal Function procedure\n                    ,                  private\n, pass(a)                  :: vec_mult_vec Function Functions private pure function magnitude_fn (this) implmentation of |vector| Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: this Return Value type( vector ) private pure function scal_add_vec (a, b) implmentation of scalar subtract vector\noverloads the + operator Arguments Type Intent Optional Attributes Name real, intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) private pure function scal_mult_vec (a, b) implmentation of scalar multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name real, intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) private pure function vec_add_scal (a, b) implmentation of vector add scalar\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) private pure function vec_add_vec (a, b) implmentation of vector add vector\noverloads the + operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) private pure function vec_div_scal (a, b) implmentation of vector divide scalar\noverloads the / operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) private pure elemental function vec_dot (a, b) result(dot) implmentation of vector dot vector\ncreates the .dot. operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value real private pure function vec_minus_vec (a, b) implmentation of vector subtract vector\noverloads the - operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) private pure function vec_mult_scal (a, b) implmentation of vector multiply scalar\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) private pure function vec_mult_vec (a, b) implmentation of vector multiply vector\noverloads the * operator Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) Subroutines private  subroutine print_sub (this) prints the vector Arguments Type Intent Optional Attributes Name class( vector ) :: this","tags":"","loc":"module/vector_class.html"},{"title":"random_mod – gridMCRT","text":"module containg routines related to random numbers Used by module~~random_mod~~UsedByGraph module~random_mod random_mod proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->module~random_mod proc~scatter scatter proc~scatter->module~random_mod proc~tauint1 tauint1 proc~tauint1->module~random_mod proc~update_pos update_pos proc~update_pos->module~random_mod program~mcpolar mcpolar program~mcpolar->module~random_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions ran2 ranu Subroutines init_seed Functions public  function ran2 () Wrapper function to fortran internal random number generator\nGenerates a random number in the range [0,1.) Arguments None Return Value real public  function ranu (a, b) sample uniformly between [a, b] Arguments Type Intent Optional Attributes Name real, intent(in) :: a input lower bound real, intent(in) :: b input upper bound Return Value real Subroutines public  subroutine init_seed (seed) user convenience function for setting random generator seed Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed user defined seed","tags":"","loc":"module/random_mod.html"},{"title":"inttau2 – gridMCRT","text":"module contains routines related to the optical depth integration of a photon though a 3D grid. Used by module~~inttau2~~UsedByGraph module~inttau2 inttau2 program~mcpolar mcpolar program~mcpolar->module~inttau2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions wall_dist Subroutines tauint1 update_pos update_voxels Functions private  function wall_dist (packet, grid, celli, cellj, cellk, pos, dir) function that returns distant to nearest wall and which wall that is (x ,y or z) Arguments Type Intent Optional Attributes Name type( photon ), intent(inout) :: packet photon packet type( cart_grid ), intent(in) :: grid grid variable container integer, intent(inout) :: celli current voxel ID integer, intent(inout) :: cellj current voxel ID integer, intent(inout) :: cellk current voxel ID type( vector ), intent(inout) :: pos current position logical, intent(inout) :: dir (:) which wall will we hit. Stored as array of bools Return Value real Subroutines public  subroutine tauint1 (packet, grid) optical depth integration subroutine. The main workhorse of MCRT Arguments Type Intent Optional Attributes Name type( photon ), intent(inout) :: packet packet to move through the grid type( cart_grid ), intent(in) :: grid grid that the packet moves through private pure subroutine update_pos (packet, grid, pos, celli, cellj, cellk, dcell, wall_flag, dir) routine that upates postions of photon and calls fresnel routines if photon leaves current voxel Arguments Type Intent Optional Attributes Name type( photon ), intent(in) :: packet photon object type( cart_grid ), intent(in) :: grid grid object type( vector ), intent(inout) :: pos current photon position integer, intent(inout) :: celli current voxel ID integer, intent(inout) :: cellj current voxel ID integer, intent(inout) :: cellk current voxel ID real, intent(in) :: dcell distance phton will travel across a cell logical, intent(in) :: wall_flag flag is true if we hit a cell wall logical, intent(in) :: dir (:) logical array. 1 entry is always true. the true entry represents which cell wall we will hit private pure subroutine update_voxels (pos, grid, celli, cellj, cellk) updates the current voxel based upon position Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: pos current photon position vector type( cart_grid ), intent(in) :: grid grid object integer, intent(inout) :: celli current voxel ID. To be updated integer, intent(inout) :: cellj current voxel ID. To be updated integer, intent(inout) :: cellk current voxel ID. To be updated","tags":"","loc":"module/inttau2.html"},{"title":"sourceph_mod – gridMCRT","text":"Module contains the routines to inialise a photon, i.e different light sources. Used by module~~sourceph_mod~~UsedByGraph module~sourceph_mod sourceph_mod program~mcpolar mcpolar program~mcpolar->module~sourceph_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines isotropic_point_src Subroutines public  subroutine isotropic_point_src (packet, grid) set intial photon position at (0.0, 0.0, 0.0) and sample photon direction in an isotropic manner. Arguments Type Intent Optional Attributes Name type( photon ), intent(out) :: packet photon object type( cart_grid ), intent(in) :: grid grid object","tags":"","loc":"module/sourceph_mod.html"},{"title":"optical_properties_class – gridMCRT","text":"Change optical properties\nSet the (scattering coefficient), (absorption coefficient) both in cm , and hgg (g factor). Used by module~~optical_properties_class~~UsedByGraph module~optical_properties_class optical_properties_class proc~gridset gridset proc~gridset->module~optical_properties_class proc~scatter scatter proc~scatter->module~optical_properties_class program~mcpolar mcpolar program~mcpolar->module~optical_properties_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types optical_properties Subroutines init_opt2 init_opt_sphere Derived Types type, public :: optical_properties Stores the optical properties of the medium. Currently only 1 media type. Can expand by making these arrays. Components Type Visibility Attributes Name Initial real, public :: albedo The albedo is real, public :: g2 Is the g factor squared real, public :: hgg hgg is the g factor. Describes the bias of the scattering direction. 1 means forward, 0 isotropic and -1 backscattering. unitless real, public :: kappa is + real, public :: mua is the absorption coefficent. in cm real, public :: mus is the scattering coefficent. in cm Subroutines public  subroutine init_opt2 (opt_prop) Set tissue optical properties 420nm Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop optical property container public  subroutine init_opt_sphere (opt_prop) Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop optical property container","tags":"","loc":"module/optical_properties_class.html"},{"title":"mcpolar – gridMCRT","text":"Uses photon_class writer_mod constants gridset_mod inttau2 optical_properties_class utils sourceph_mod random_mod program~~mcpolar~~UsesGraph program~mcpolar mcpolar module~constants constants program~mcpolar->module~constants module~gridset_mod gridset_mod program~mcpolar->module~gridset_mod module~inttau2 inttau2 program~mcpolar->module~inttau2 module~optical_properties_class optical_properties_class program~mcpolar->module~optical_properties_class module~photon_class photon_class program~mcpolar->module~photon_class module~random_mod random_mod program~mcpolar->module~random_mod module~sourceph_mod sourceph_mod program~mcpolar->module~sourceph_mod module~utils utils program~mcpolar->module~utils module~writer_mod writer_mod program~mcpolar->module~writer_mod module~vector_class vector_class module~gridset_mod->module~vector_class module~photon_class->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. *** Read in parameters from the file input.params Calls program~~mcpolar~~CallsGraph program~mcpolar mcpolar interface~str str program~mcpolar->interface~str proc~gridset gridset program~mcpolar->proc~gridset proc~init_opt_sphere init_opt_sphere program~mcpolar->proc~init_opt_sphere proc~init_seed init_seed program~mcpolar->proc~init_seed proc~isotropic_point_src isotropic_point_src program~mcpolar->proc~isotropic_point_src proc~ran2 ran2 program~mcpolar->proc~ran2 proc~set_directories set_directories program~mcpolar->proc~set_directories proc~tauint1 tauint1 program~mcpolar->proc~tauint1 proc~writer writer program~mcpolar->proc~writer proc~str_i32 str_I32 interface~str->proc~str_i32 proc~str_i64 str_I64 interface~str->proc~str_i64 proc~str_iarray str_iarray interface~str->proc~str_iarray proc~str_logicalarray str_logicalarray interface~str->proc~str_logicalarray proc~str_r8 str_R8 interface~str->proc~str_r8 proc~str_r8array str_R8array interface~str->proc~str_r8array proc~alloc_array alloc_array proc~gridset->proc~alloc_array proc~zarray zarray proc~gridset->proc~zarray proc~isotropic_point_src->proc~ran2 proc~tauint1->proc~ran2 proc~update_pos update_pos proc~tauint1->proc~update_pos proc~wall_dist wall_dist proc~tauint1->proc~wall_dist proc~update_voxels update_voxels proc~update_pos->proc~update_voxels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Variables finish grid j nphotons nscatt nxg nyg nzg opt_prop packet seed start u xmax ymax zmax Source Code mcpolar Variables Type Attributes Name Initial real :: finish timing vars type( cart_grid ) :: grid variable that holds the 3D grid information integer :: j loop variable integer :: nphotons number of photons to run in the simulation double precision :: nscatt counter for number of scatterings for all photons integer :: nxg temp variables related to I/O from param file integer :: nyg temp variables related to I/O from param file integer :: nzg temp variables related to I/O from param file type( optical_properties ) :: opt_prop optical properties variable type( photon ) :: packet variable that holds all information about the photon to be simulated integer :: seed user defined seed real :: start timing vars integer :: u file handle real :: xmax temp variables related to I/O from param file real :: ymax temp variables related to I/O from param file real :: zmax temp variables related to I/O from param file Source Code program mcpolar !imports use constants , only : resdir use gridset_mod , only : gridset , cart_grid use inttau2 , only : tauint1 use optical_properties_class , only : optical_properties , init_opt_sphere use photon_class , only : photon use random_mod , only : ran2 , init_seed use sourceph_mod , only : isotropic_point_src use utils , only : set_directories , str use writer_mod , only : writer implicit none !> variable that holds all information about the photon to be simulated type ( photon ) :: packet !> variable that holds the 3D grid information type ( cart_grid ) :: grid !> optical properties variable type ( optical_properties ) :: opt_prop !> number of photons to run in the simulation integer :: nphotons !> counter for number of scatterings for all photons double precision :: nscatt !> user defined seed integer :: seed !> temp variables related to I/O from param file integer :: nxg , nyg , nzg !> loop variable integer :: j !> file handle integer :: u !> temp variables related to I/O from param file real :: xmax , ymax , zmax !> timing vars real :: start , finish call cpu_time ( start ) !set directory paths call set_directories () !set optical properties call init_opt_sphere ( opt_prop ) !set random seed seed = 42 call init_seed ( seed ) !**** Read in parameters from the file input.params open ( newunit = u , file = trim ( resdir ) // 'input.params' , status = 'old' ) read ( u , * ) nphotons read ( u , * ) xmax read ( u , * ) ymax read ( u , * ) zmax read ( u , * ) nxg read ( u , * ) nyg read ( u , * ) nzg close ( u ) print * , '' print * , '# of photons to run' , nphotons ! Set up grid call gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) ! inialise the number of scatterings counter nscatt = 0 print * , 'Photons now running' !loop over photons do j = 1 , nphotons !display progress if ( mod ( j , 10000 ) == 0 ) then print * , str ( j ) // ' scattered photons completed' end if ! Release photon from point source call isotropic_point_src ( packet , grid ) ! Find scattering location call tauint1 ( packet , grid ) ! Photon scatters in grid until it exits (tflag=TRUE) do while (. not . packet % tflag ) !interact with medium if ( ran2 () < opt_prop % albedo ) then ! photon is scattered call packet % scatter ( opt_prop ) nscatt = nscatt + 1 else ! photon is absorbed packet % tflag = . true . exit end if ! Find next scattering location call tauint1 ( packet , grid ) end do end do ! end loop over nph photons print * , 'Average # of scatters per photon: ' // str ( nscatt / ( nphotons )) !write out files call writer ( grid , nphotons ) print * , 'write done' call cpu_time ( finish ) if ( finish - start >= 6 0. ) then print * , floor (( finish - start ) / 6 0. ) + mod ( finish - start , 6 0. ) / 10 0. else print * , 'time taken ~' // str ( floor ( finish - start / 6 0. )) // 's' end if end program mcpolar","tags":"","loc":"program/mcpolar.html"},{"title":"iarray.f90 – gridMCRT","text":"Files dependent on this one sourcefile~~iarray.f90~~AfferentGraph sourcefile~iarray.f90 iarray.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~iarray.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~gridset.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~writer.f90->sourcefile~gridset.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules iarray Source Code iarray.f90 Source Code module iarray !!  Contains all array variable names. implicit none !> stores the optical properties, i.e the total cross section \\mu_t = \\mu_s + \\mu_a real , allocatable :: rhokap (:,:,:) end module iarray","tags":"","loc":"sourcefile/iarray.f90.html"},{"title":"writer.f90 – gridMCRT","text":"This file depends on sourcefile~~writer.f90~~EfferentGraph sourcefile~writer.f90 writer.f90 sourcefile~constants.f90 constants.f90 sourcefile~writer.f90->sourcefile~constants.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~writer.f90->sourcefile~gridset.f90 sourcefile~iarray.f90 iarray.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~writer.f90~~AfferentGraph sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules writer_mod Source Code writer.f90 Source Code module writer_mod !! I/O related routines. implicit none contains subroutine writer ( grid , nphotons ) !! subroutine to write out normalised fluence use constants , only : fileplace use gridset_mod , only : cart_grid !> grid type ( cart_grid ), intent ( in ) :: grid !> number of photons to normalise by integer , intent ( in ) :: nphotons ! normalise fluence assuming power is 1W ! write out fluence end subroutine writer end module writer_mod","tags":"","loc":"sourcefile/writer.f90.html"},{"title":"photon_class.f90 – gridMCRT","text":"This file depends on sourcefile~~photon_class.f90~~EfferentGraph sourcefile~photon_class.f90 photon_class.f90 sourcefile~constants.f90 constants.f90 sourcefile~photon_class.f90->sourcefile~constants.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~photon_class.f90->sourcefile~optical_properties.f90 sourcefile~random_mod.f90 random_mod.f90 sourcefile~photon_class.f90->sourcefile~random_mod.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~photon_class.f90->sourcefile~vector_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~photon_class.f90~~AfferentGraph sourcefile~photon_class.f90 photon_class.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules photon_class Source Code photon_class.f90 Source Code module photon_class !! Module defines the photon class and scattering routines use vector_class , only : vector implicit none !> photon type. Encapsulates all information about a single photon. type :: photon !> direction vector type ( vector ) :: dir !> position vector type ( vector ) :: pos !> sin(theta). \\theta is the polar angle in the physics spherical coordinate system real :: sint !> cos(\\theta) \\theta is the polar angle in the physics spherical coordinate system real :: cost !> sin(\\phi) \\phi is the azimuthal angle in the physics spherical coordinate system real :: sinp !> cos(\\phi) \\phi is the azimuthal angle in the physics spherical coordinate system real :: cosp !> \\phi \\phi is the azimuthal angle in the physics spherical coordinate system real :: phi !> Boolean flag that if true photon is alive and in the simulation logical :: tflag !> Current voxel which the photon is in integer :: xcell , ycell , zcell contains procedure :: scatter end type photon contains subroutine scatter ( this , opt_prop ) !! photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0) !! adapted from mcxyz [https://omlc.org/software/mc/mcxyz/index.html](https://omlc.org/software/mc/mcxyz/index.html) use optical_properties_class , only : optical_properties use constants , only : PI , TWOPI use random_mod , only : ran2 !> photon packet class ( photon ) :: this !> optical properties type ( optical_properties ), intent ( in ) :: opt_prop real :: temp , uxx , uyy , uzz if ( opt_prop % hgg == 0.0 ) then !isotropic scattering this % cost = 2. * ran2 () - 1. else !henyey-greenstein scattering temp = ( 1.0 - opt_prop % g2 ) / ( 1.0 - opt_prop % hgg + 2. * opt_prop % hgg * ran2 ()) this % cost = ( 1.0 + opt_prop % g2 - temp ** 2 ) / ( 2. * opt_prop % hgg ) end if this % sint = sqrt ( 1. - this % cost ** 2 ) this % phi = TWOPI * ran2 () this % cosp = cos ( this % phi ) if ( this % phi < PI ) then this % sinp = sqrt ( 1. - this % cosp ** 2 ) else this % sinp = - sqrt ( 1. - this % cosp ** 2 ) end if if ( 1. - abs ( this % dir % z ) <= 1e-12 ) then ! near perpindicular uxx = this % sint * this % cosp uyy = this % sint * this % sinp uzz = sign ( this % cost , this % dir % z ) else temp = sqrt ( 1. - this % dir % z ** 2 ) uxx = this % sint * ( this % dir % x * this % dir % z * this % cosp - this % dir % y * this % sinp ) & / temp + this % dir % x * this % cost uyy = this % sint * ( this % dir % y * this % dir % z * this % cosp + this % dir % x * this % sinp ) & / temp + this % dir % y * this % cost uzz = - 1. * this % sint * this % cosp * temp + this % dir % z * this % cost end if this % dir % x = uxx this % dir % y = uyy this % dir % z = uzz end subroutine scatter end module photon_class","tags":"","loc":"sourcefile/photon_class.f90.html"},{"title":"gridset.f90 – gridMCRT","text":"This file depends on sourcefile~~gridset.f90~~EfferentGraph sourcefile~gridset.f90 gridset.f90 sourcefile~iarray.f90 iarray.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~gridset.f90~~AfferentGraph sourcefile~gridset.f90 gridset.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~gridset.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~writer.f90->sourcefile~gridset.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules gridset_mod Source Code gridset.f90 Source Code module gridset_mod !! Module provides a cartesian grid type to store all grid related variables in a container !! Also provides a way of setting up the geomerty/grid for the simulation. use vector_class , only : vector implicit none private public :: gridset , cart_grid !> 3D cartesian grid. Stores information about the linear voxel grid type :: cart_grid !> Size of grid in voxels in each direction integer :: nxg , nyg , nzg !> half size of grid in each dimension. cm type ( vector ) :: dim !> Arrays that store the location of each grid cell(voxel) wall real , allocatable :: xface (:), yface (:), zface (:) !> ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls real :: delta end type cart_grid contains subroutine gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) !! Set up grids and create geometry use iarray , only : rhokap , rhokap use optical_properties_class , only : optical_properties !> grid variable that is assigned in this routine type ( cart_grid ), intent ( out ) :: grid !> optical properties used to setup voxel geometry type ( optical_properties ), intent ( in ) :: opt_prop !> number of voxels in each dimension integer , intent ( in ) :: nxg , nyg , nzg !> half size of the grid in cm real , intent ( in ) :: xmax , ymax , zmax !> loop variables integer :: i , j , k !> temp variables real :: x , y , z , taueq1 , taupole1 , taueq2 , taupole2 print * , ' ' print * , 'Setting up grid....' ! set grid dimensions and voxel numbers grid % dim = vector ( xmax , ymax , zmax ) grid % nxg = nxg grid % nyg = nyg grid % nzg = nzg ! Set small distance for use in optical depth integration routines ! for roundoff effects when crossing cell walls grid % delta = 1.e-8 * ( 2. * grid % dim % z / grid % nzg ) ! allocate and set arrays to 0 call alloc_array ( grid ) call zarray ( grid ) ! setup grid cell walls do i = 1 , grid % nxg + 1 grid % xface ( i ) = ( i - 1 ) * 2. * grid % dim % x / grid % nxg end do do i = 1 , grid % nyg + 1 grid % yface ( i ) = ( i - 1 ) * 2. * grid % dim % y / grid % nyg end do do i = 1 , grid % nzg + 1 grid % zface ( i ) = ( i - 1 ) * 2. * grid % dim % z / grid % nzg end do !set up optical properties grid do i = 1 , grid % nxg x = grid % xface ( i ) - grid % dim % x + grid % dim % x / grid % nxg do j = 1 , grid % nyg y = grid % yface ( j ) - grid % dim % y + grid % dim % y / grid % nyg do k = 1 , grid % nzg z = grid % zface ( k ) - grid % dim % z + grid % dim % z / grid % nzg ! create a sphere of radius 1. if ( sqrt ( x ** 2 + y ** 2 + z ** 2 ) <= 1. ) then rhokap ( i , j , k ) = opt_prop % kappa else rhokap ( i , j , k ) = 0. end if end do end do end do ! Calculate equatorial and polar optical depths taueq1 = 0. taupole1 = 0. taueq2 = 0. taupole2 = 0. do i = 1 , grid % nxg taueq1 = taueq1 + rhokap ( i , grid % nyg / 2 , grid % nzg / 2 ) end do do i = 1 , grid % nzg taupole1 = taupole1 + rhokap ( grid % nxg / 2 , grid % nyg / 2 , i ) end do taueq1 = taueq1 * 2. * grid % dim % x / grid % nxg taupole1 = taupole1 * 2. * grid % dim % z / grid % nzg print '(A,F9.5,A,F9.5)' , ' taueq1 = ' , taueq1 , '  taupole1 = ' , taupole1 end subroutine gridset subroutine zarray ( grid ) !! set all 3D arrays to zero use iarray , only : rhokap type ( cart_grid ), intent ( inout ) :: grid rhokap = 0. grid % xface = 0. grid % yface = 0. grid % zface = 0. end subroutine zarray subroutine alloc_array ( grid ) !!  allocates allocatable 3D arrays use iarray , only : rhokap type ( cart_grid ), intent ( inout ) :: grid allocate ( rhokap ( grid % nxg , grid % nyg , grid % nzg )) allocate ( grid % xface ( grid % nxg + 1 )) allocate ( grid % yface ( grid % nyg + 1 )) allocate ( grid % zface ( grid % nzg + 1 )) end subroutine alloc_array end module gridset_mod","tags":"","loc":"sourcefile/gridset.f90.html"},{"title":"mcpolar.f90 – gridMCRT","text":"This file depends on sourcefile~~mcpolar.f90~~EfferentGraph sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~constants.f90 constants.f90 sourcefile~mcpolar.f90->sourcefile~constants.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~mcpolar.f90->sourcefile~gridset.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~mcpolar.f90->sourcefile~optical_properties.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~random_mod.f90 random_mod.f90 sourcefile~mcpolar.f90->sourcefile~random_mod.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~utils.f90 utils.f90 sourcefile~mcpolar.f90->sourcefile~utils.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~iarray.f90 iarray.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~inttau2.f90->sourcefile~random_mod.f90 sourcefile~inttau2.f90->sourcefile~utils.f90 sourcefile~inttau2.f90->sourcefile~iarray.f90 sourcefile~inttau2.f90->sourcefile~vector_class.f90 sourcefile~photon_class.f90->sourcefile~constants.f90 sourcefile~photon_class.f90->sourcefile~optical_properties.f90 sourcefile~photon_class.f90->sourcefile~random_mod.f90 sourcefile~photon_class.f90->sourcefile~vector_class.f90 sourcefile~sourceph.f90->sourcefile~constants.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 sourcefile~sourceph.f90->sourcefile~random_mod.f90 sourcefile~utils.f90->sourcefile~constants.f90 sourcefile~writer.f90->sourcefile~constants.f90 sourcefile~writer.f90->sourcefile~gridset.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Programs mcpolar Source Code mcpolar.f90 Source Code program mcpolar !imports use constants , only : resdir use gridset_mod , only : gridset , cart_grid use inttau2 , only : tauint1 use optical_properties_class , only : optical_properties , init_opt_sphere use photon_class , only : photon use random_mod , only : ran2 , init_seed use sourceph_mod , only : isotropic_point_src use utils , only : set_directories , str use writer_mod , only : writer implicit none !> variable that holds all information about the photon to be simulated type ( photon ) :: packet !> variable that holds the 3D grid information type ( cart_grid ) :: grid !> optical properties variable type ( optical_properties ) :: opt_prop !> number of photons to run in the simulation integer :: nphotons !> counter for number of scatterings for all photons double precision :: nscatt !> user defined seed integer :: seed !> temp variables related to I/O from param file integer :: nxg , nyg , nzg !> loop variable integer :: j !> file handle integer :: u !> temp variables related to I/O from param file real :: xmax , ymax , zmax !> timing vars real :: start , finish call cpu_time ( start ) !set directory paths call set_directories () !set optical properties call init_opt_sphere ( opt_prop ) !set random seed seed = 42 call init_seed ( seed ) !**** Read in parameters from the file input.params open ( newunit = u , file = trim ( resdir ) // 'input.params' , status = 'old' ) read ( u , * ) nphotons read ( u , * ) xmax read ( u , * ) ymax read ( u , * ) zmax read ( u , * ) nxg read ( u , * ) nyg read ( u , * ) nzg close ( u ) print * , '' print * , '# of photons to run' , nphotons ! Set up grid call gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) ! inialise the number of scatterings counter nscatt = 0 print * , 'Photons now running' !loop over photons do j = 1 , nphotons !display progress if ( mod ( j , 10000 ) == 0 ) then print * , str ( j ) // ' scattered photons completed' end if ! Release photon from point source call isotropic_point_src ( packet , grid ) ! Find scattering location call tauint1 ( packet , grid ) ! Photon scatters in grid until it exits (tflag=TRUE) do while (. not . packet % tflag ) !interact with medium if ( ran2 () < opt_prop % albedo ) then ! photon is scattered call packet % scatter ( opt_prop ) nscatt = nscatt + 1 else ! photon is absorbed packet % tflag = . true . exit end if ! Find next scattering location call tauint1 ( packet , grid ) end do end do ! end loop over nph photons print * , 'Average # of scatters per photon: ' // str ( nscatt / ( nphotons )) !write out files call writer ( grid , nphotons ) print * , 'write done' call cpu_time ( finish ) if ( finish - start >= 6 0. ) then print * , floor (( finish - start ) / 6 0. ) + mod ( finish - start , 6 0. ) / 10 0. else print * , 'time taken ~' // str ( floor ( finish - start / 6 0. )) // 's' end if end program mcpolar","tags":"","loc":"sourcefile/mcpolar.f90.html"},{"title":"utils.f90 – gridMCRT","text":"This file depends on sourcefile~~utils.f90~~EfferentGraph sourcefile~utils.f90 utils.f90 sourcefile~constants.f90 constants.f90 sourcefile~utils.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~utils.f90~~AfferentGraph sourcefile~utils.f90 utils.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~utils.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~utils.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules utils Source Code utils.f90 Source Code module utils !! module that contains utility functions and helper routines. implicit none !>functions to turn numerical variables into strings interface str module procedure str_I32 module procedure str_I64 module procedure str_Iarray module procedure str_R8 module procedure str_R8array module procedure str_logicalarray end interface str private public :: str , set_directories contains subroutine set_directories () !! define variables to hold paths to various folders use constants , only : homedir , fileplace , resdir character ( len = 255 ) :: cwd !get current working directory call get_environment_variable ( 'PWD' , cwd ) ! get 'home' dir from cwd if ( index ( cwd , \"bin\" ) > 0 ) then ! if program is run from bin dir homedir = trim ( cwd ( 1 : len ( trim ( cwd )) - 3 )) else ! program is run from root dir homedir = trim ( cwd ) // \"/\" end if ! get data dir fileplace = trim ( homedir ) // 'data/' ! get res dir resdir = trim ( homedir ) // 'res/' end subroutine set_directories function str_I32 ( i ) !! convert an int32 integer into a string use iso_fortran_env , only : Int32 !> input int to convert into string integer ( int32 ), intent ( IN ) :: i character ( len = :), allocatable :: str_I32 character ( len = 100 ) :: string write ( string , '(I100.1)' ) I str_I32 = trim ( adjustl ( string )) end function str_I32 function str_I64 ( i ) !! convert an int64 integer into a string use iso_fortran_env , only : Int64 !> input int to convert into string integer ( Int64 ), intent ( IN ) :: i character ( len = :), allocatable :: str_I64 character ( len = 100 ) :: string write ( string , '(I100.1)' ) I str_I64 = trim ( adjustl ( string )) end function str_I64 function str_iarray ( i ) !! convert an int32 integer array into a string !> input int array to convert into string integer , intent ( IN ) :: i (:) character ( len = :), allocatable :: str_iarray character ( len = 100 ) :: string integer :: j do j = 1 , size ( i ) write ( string , '(I100.1)' ) I ( j ) str_iarray = str_iarray // ' ' // trim ( adjustl ( string )) end do end function str_iarray function str_R8 ( i ) !! convert an double precision float into a string !> input float to convert into string double precision , intent ( IN ) :: i character ( len = :), allocatable :: str_R8 character ( len = 100 ) :: string write ( string , '(f100.16)' ) I str_R8 = trim ( adjustl ( string )) end function str_r8 function str_R8array ( a ) !! convert an double precision float array into a string !> input float array to convert into string double precision , intent ( IN ) :: a (:) character ( len = :), allocatable :: str_R8array character ( len = 100 ) :: string integer :: i do i = 1 , size ( a ) write ( string , '(f100.16)' ) a ( i ) str_R8array = str_R8array // ' ' // trim ( adjustl ( string )) end do end function str_R8array function str_logicalarray ( a ) !! convert an logical array into a string !> input logical array to convert into string logical , intent ( IN ) :: a (:) character ( len = :), allocatable :: str_logicalarray character ( len = 100 ) :: string integer :: i do i = 1 , size ( a ) write ( string , '(L1)' ) a ( i ) str_logicalarray = str_logicalarray // ' ' // trim ( adjustl ( string )) end do end function str_logicalarray end module utils","tags":"","loc":"sourcefile/utils.f90.html"},{"title":"constants.f90 – gridMCRT","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~constants.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~utils.f90 utils.f90 sourcefile~mcpolar.f90->sourcefile~utils.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~photon_class.f90->sourcefile~constants.f90 sourcefile~sourceph.f90->sourcefile~constants.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 sourcefile~utils.f90->sourcefile~constants.f90 sourcefile~writer.f90->sourcefile~constants.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~inttau2.f90->sourcefile~utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules constants Source Code constants.f90 Source Code module constants !! Constants used throughout the simulation. implicit none !> mathematical constants real , parameter :: PI = 4. * atan ( 1. ), TWOPI = 2. * PI !> variables that stores the home (root) directory character ( len = 255 ) :: homedir !> variables that stores the directory where output files are saved character ( len = 255 ) :: fileplace !> variables that stores the directory for input files. character ( len = 255 ) :: resdir end module constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"vector_class.f90 – gridMCRT","text":"Files dependent on this one sourcefile~~vector_class.f90~~AfferentGraph sourcefile~vector_class.f90 vector_class.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~vector_class.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~photon_class.f90->sourcefile~vector_class.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~gridset.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 sourcefile~writer.f90->sourcefile~gridset.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules vector_class Source Code vector_class.f90 Source Code Module vector_class !! Module contains the vector class and associated routines. implicit none !> Vector type used for direction and position vectors !> supports all possible vector operations type :: vector !> components of the vector real :: x , y , z contains !> get the magnitde of a vector procedure :: magnitude => magnitude_fn !> print a vector procedure :: print => print_sub !> get the dot product of two vectors generic :: operator (. dot .) => vec_dot !> divide a vector by a float generic :: operator ( / ) => vec_div_scal !> multiple a vector by a scalar or vector (element wise) generic :: operator ( * ) => vec_mult_vec , vec_mult_scal , scal_mult_vec !> add two vectors, or a vector and a scalar generic :: operator ( + ) => vec_add_vec , vec_add_scal , scal_add_vec !> subtract a vector from a vector generic :: operator ( - ) => vec_minus_vec procedure , pass ( a ), private :: vec_dot procedure , pass ( a ), private :: vec_div_scal procedure , pass ( a ), private :: vec_mult_vec procedure , pass ( a ), private :: vec_mult_scal procedure , pass ( b ), private :: scal_mult_vec procedure , pass ( a ), private :: vec_add_vec procedure , pass ( a ), private :: vec_add_scal procedure , pass ( b ), private :: scal_add_vec procedure , pass ( a ), private :: vec_minus_vec end type vector private public :: vector contains pure type ( vector ) function vec_minus_vec ( a , b ) !! implmentation of vector subtract vector !! overloads the - operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_minus_vec = vector ( a % x - b % x , a % y - b % y , a % z - b % z ) end function vec_minus_vec pure type ( vector ) function vec_add_scal ( a , b ) !! implmentation of vector add scalar !! overloads the + operator class ( vector ), intent ( IN ) :: a real , intent ( IN ) :: b vec_add_scal = vector ( a % x + b , a % y + b , a % z + b ) end function vec_add_scal pure type ( vector ) function scal_add_vec ( a , b ) !! implmentation of scalar subtract vector !! overloads the + operator class ( vector ), intent ( IN ) :: b real , intent ( IN ) :: a scal_add_vec = vector ( b % x + a , b % y + a , b % z + a ) end function scal_add_vec pure type ( vector ) function vec_add_vec ( a , b ) !! implmentation of vector add vector !! overloads the + operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_add_vec = vector ( a % x + b % x , a % y + b % y , a % z + b % z ) end function vec_add_vec pure elemental function vec_dot ( a , b ) result ( dot ) !! implmentation of vector dot vector !! creates the .dot. operator class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b real :: dot dot = ( a % x * b % x ) + ( a % y * b % y ) + ( a % z * b % z ) end function vec_dot pure type ( vector ) function vec_mult_vec ( a , b ) !! implmentation of vector multiply vector !! overloads the * operator !@note !    This is ELEMENT wise multiplication !@end note class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_mult_vec = vector ( a % x * b % x , a % y * b % y , a % z * b % z ) end function vec_mult_vec pure type ( vector ) function vec_mult_scal ( a , b ) !! implmentation of vector multiply scalar !! overloads the * operator class ( vector ), intent ( IN ) :: a real , intent ( IN ) :: b vec_mult_scal = vector ( a % x * b , a % y * b , a % z * b ) end function vec_mult_scal pure type ( vector ) function scal_mult_vec ( a , b ) !! implmentation of scalar multiply vector !! overloads the * operator class ( vector ), intent ( IN ) :: b real , intent ( IN ) :: a scal_mult_vec = vector ( a * b % x , a * b % y , a * b % z ) end function scal_mult_vec pure type ( vector ) function vec_div_scal ( a , b ) !! implmentation of vector divide scalar !! overloads the / operator class ( vector ), intent ( IN ) :: a real , intent ( IN ) :: b vec_div_scal = vector ( a % x / b , a % y / b , a % z / b ) end function vec_div_scal pure type ( vector ) function magnitude_fn ( this ) !! implmentation of |vector| class ( vector ), intent ( in ) :: this real :: tmp tmp = sqrt ( this % x ** 2 + this % y ** 2 + this % z ** 2 ) magnitude_fn = this / tmp end function magnitude_fn subroutine print_sub ( this ) !! prints the vector class ( vector ) :: this print * , this % x , this % y , this % z end subroutine print_sub end Module vector_class","tags":"","loc":"sourcefile/vector_class.f90.html"},{"title":"random_mod.f90 – gridMCRT","text":"Files dependent on this one sourcefile~~random_mod.f90~~AfferentGraph sourcefile~random_mod.f90 random_mod.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~random_mod.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~random_mod.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~photon_class.f90->sourcefile~random_mod.f90 sourcefile~sourceph.f90->sourcefile~random_mod.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules random_mod Source Code random_mod.f90 Source Code module random_mod !! module containg routines related to random numbers implicit none private public :: ran2 , ranu , init_seed contains subroutine init_seed ( seed ) !! user convenience function for setting random generator seed !> user defined seed integer , intent ( in ) :: seed !> size of internal seed array integer :: n !> internal seed array to be filled with user defined seed integer , allocatable :: iseed (:) ! get seed size call random_seed ( size = n ) allocate ( iseed ( n )) ! put user seed in actual seed iseed = seed ! seed the RNG call random_seed ( put = iseed ) end subroutine init_seed real function ran2 () !! Wrapper function to fortran internal random number generator !! Generates a random number in the range [0,1.) call random_number ( ran2 ) end function ran2 real function ranu ( a , b ) !! sample uniformly between [a, b] !> input lower bound real , intent ( in ) :: a !> input upper bound real , intent ( in ) :: b ranu = a + ran2 () * ( b - a ) end function ranu end module random_mod","tags":"","loc":"sourcefile/random_mod.f90.html"},{"title":"inttau2.f90 – gridMCRT","text":"This file depends on sourcefile~~inttau2.f90~~EfferentGraph sourcefile~inttau2.f90 inttau2.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~iarray.f90 iarray.f90 sourcefile~inttau2.f90->sourcefile~iarray.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~random_mod.f90 random_mod.f90 sourcefile~inttau2.f90->sourcefile~random_mod.f90 sourcefile~utils.f90 utils.f90 sourcefile~inttau2.f90->sourcefile~utils.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~inttau2.f90->sourcefile~vector_class.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~photon_class.f90->sourcefile~random_mod.f90 sourcefile~photon_class.f90->sourcefile~vector_class.f90 sourcefile~constants.f90 constants.f90 sourcefile~photon_class.f90->sourcefile~constants.f90 sourcefile~photon_class.f90->sourcefile~optical_properties.f90 sourcefile~utils.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~inttau2.f90~~AfferentGraph sourcefile~inttau2.f90 inttau2.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules inttau2 Source Code inttau2.f90 Source Code module inttau2 !! module contains routines related to the optical depth integration of a photon though a 3D grid. implicit none private public :: tauint1 CONTAINS subroutine tauint1 ( packet , grid ) !! optical depth integration subroutine. The main workhorse of MCRT use gridset_mod , only : cart_grid use iarray , only : rhokap use photon_class , only : photon use random_mod , only : ran2 use vector_class , only : vector !> packet to move through the grid type ( photon ), intent ( inout ) :: packet !> grid that the packet moves through type ( cart_grid ), intent ( in ) :: grid ! intermediate position type ( vector ) :: pos real :: tau , taurun , taucell , d , dcell integer :: celli , cellj , cellk logical :: dir ( 3 ) !change grid origin to lower left of the grid pos = packet % pos + grid % dim ! store current voxel in temp variables celli = packet % xcell cellj = packet % ycell cellk = packet % zcell ! setup to start integrating taurun = 0. d = 0. dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !sample optical distance tau = - log ( ran2 ()) do dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !get distance to nearest wall in direction dir dcell = wall_dist ( packet , grid , celli , cellj , cellk , pos , dir ) !calculate optical distnace to cell wall taucell = dcell * rhokap ( celli , cellj , cellk ) if ( taurun + taucell < tau ) then !still some tau to move taurun = taurun + taucell d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . TRUE ., dir ) else !moved full distance dcell = ( tau - taurun ) / rhokap ( celli , cellj , cellk ) d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . FALSE ., dir ) exit end if if ( celli == - 1 . or . cellj == - 1 . or . cellk == - 1 ) then packet % tflag = . true . exit end if end do ! move back to grid with origin at the centre packet % pos = pos - grid % dim packet % xcell = celli packet % ycell = cellj packet % zcell = cellk end subroutine tauint1 real function wall_dist ( packet , grid , celli , cellj , cellk , pos , dir ) !!function that returns distant to nearest wall and which wall that is (x ,y or z) use gridset_mod , only : cart_grid use photon_class , only : photon use vector_class , only : vector !> photon packet type ( photon ), intent ( inout ) :: packet !> grid variable container type ( cart_grid ), intent ( in ) :: grid !> current position type ( vector ), intent ( inout ) :: pos !> which wall will we hit. Stored as array of bools logical , intent ( inout ) :: dir (:) !> current voxel ID integer , intent ( inout ) :: celli , cellj , cellk real :: dx , dy , dz ! get distance to a wall in the x direction if ( packet % dir % x > 0. ) then dx = ( grid % xface ( celli + 1 ) - pos % x ) / packet % dir % x elseif ( packet % dir % x < 0. ) then dx = ( grid % xface ( celli ) - pos % x ) / packet % dir % x elseif ( packet % dir % x == 0. ) then dx = 10000 0. end if ! get distance to a wall in the y direction if ( packet % dir % y > 0. ) then dy = ( grid % yface ( cellj + 1 ) - pos % y ) / packet % dir % y elseif ( packet % dir % y < 0. ) then dy = ( grid % yface ( cellj ) - pos % y ) / packet % dir % y elseif ( packet % dir % y == 0. ) then dy = 10000 0. end if ! get distance to a wall in the z direction if ( packet % dir % z > 0. ) then dz = ( grid % zface ( cellk + 1 ) - pos % z ) / packet % dir % z elseif ( packet % dir % z < 0. ) then dz = ( grid % zface ( cellk ) - pos % z ) / packet % dir % z elseif ( packet % dir % z == 0. ) then dz = 10000 0. end if !get closest wall wall_dist = min ( dx , dy , dz ) if ( wall_dist < 0. ) print '(A,7F9.5)' , 'dcell < 0.0 warning! ' , wall_dist , dx , dy , dz , packet % dir if ( wall_dist == dx ) dir = ( / . TRUE ., . FALSE ., . FALSE . / ) if ( wall_dist == dy ) dir = ( / . FALSE ., . TRUE ., . FALSE . / ) if ( wall_dist == dz ) dir = ( / . FALSE ., . FALSE ., . TRUE . / ) if (. not . dir ( 1 ) . and . . not . dir ( 2 ) . and . . not . dir ( 3 )) print * , 'Error in dir flag' end function wall_dist pure subroutine update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , wall_flag , dir ) !! routine that upates postions of photon and calls fresnel routines if photon leaves current voxel use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 use utils , only : str use vector_class , only : vector !> photon object type ( photon ), intent ( in ) :: packet !> current photon position type ( vector ), intent ( inout ) :: pos !> grid object type ( cart_grid ), intent ( in ) :: grid !> distance phton will travel across a cell real , intent ( in ) :: dcell !> current voxel ID integer , intent ( inout ) :: celli , cellj , cellk !> flag is true if we hit a cell wall logical , intent ( in ) :: wall_flag !> logical array. 1 entry is always true. the true entry represents which cell wall we will hit logical , intent ( in ) :: dir (:) ! if we hit a wall if ( wall_flag ) then ! in the x direction if ( dir ( 1 )) then if ( packet % dir % x > 0. ) then pos % x = grid % xface ( celli + 1 ) + grid % delta celli = celli + 1 elseif ( packet % dir % x < 0. ) then pos % x = grid % xface ( celli ) - grid % delta celli = celli - 1 else error stop 'Error in x dir in update_pos' end if pos % y = pos % y + packet % dir % y * dcell pos % z = pos % z + packet % dir % z * dcell ! y direction elseif ( dir ( 2 )) then if ( packet % dir % y > 0. ) then pos % y = grid % yface ( cellj + 1 ) + grid % delta cellj = cellj + 1 elseif ( packet % dir % y < 0. ) then pos % y = grid % yface ( cellj ) - grid % delta cellj = cellj - 1 else error stop 'Error in y dir in update_pos' end if pos % x = pos % x + packet % dir % x * dcell pos % z = pos % z + packet % dir % z * dcell ! z direction elseif ( dir ( 3 )) then if ( packet % dir % z > 0. ) then pos % z = grid % zface ( cellk + 1 ) + grid % delta cellk = cellk + 1 elseif ( packet % dir % z < 0. ) then pos % z = grid % zface ( cellk ) - grid % delta cellk = cellk - 1 else error stop 'Error in z dir in update_pos' end if pos % x = pos % x + packet % dir % x * dcell pos % y = pos % y + packet % dir % y * dcell else error stop 'Error in update_pos...' end if else ! we dont hit a wall pos = pos + packet % dir * dcell end if if ( wall_flag ) then ! if we hit a wall, get current voxel call update_voxels ( pos , grid , celli , cellj , cellk ) end if end subroutine update_pos pure subroutine update_voxels ( pos , grid , celli , cellj , cellk ) !! updates the current voxel based upon position use gridset_mod , only : cart_grid use vector_class , only : vector !> current photon position vector type ( vector ), intent ( in ) :: pos !> grid object type ( cart_grid ), intent ( in ) :: grid !> current voxel ID. To be updated integer , intent ( inout ) :: celli , cellj , cellk celli = floor ( grid % nxg * ( pos % x ) / ( 2. * grid % dim % x )) + 1 cellj = floor ( grid % nyg * ( pos % y ) / ( 2. * grid % dim % y )) + 1 cellk = floor ( grid % nzg * ( pos % z ) / ( 2. * grid % dim % z )) + 1 if ( celli > grid % nxg . or . celli < 1 ) celli = - 1 if ( cellj > grid % nyg . or . cellj < 1 ) cellj = - 1 if ( cellk > grid % nzg . or . cellk < 1 ) cellk = - 1 end subroutine update_voxels end module inttau2","tags":"","loc":"sourcefile/inttau2.f90.html"},{"title":"sourceph.f90 – gridMCRT","text":"This file depends on sourcefile~~sourceph.f90~~EfferentGraph sourcefile~sourceph.f90 sourceph.f90 sourcefile~constants.f90 constants.f90 sourcefile~sourceph.f90->sourcefile~constants.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 sourcefile~random_mod.f90 random_mod.f90 sourcefile~sourceph.f90->sourcefile~random_mod.f90 sourcefile~iarray.f90 iarray.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 sourcefile~photon_class.f90->sourcefile~constants.f90 sourcefile~photon_class.f90->sourcefile~random_mod.f90 sourcefile~photon_class.f90->sourcefile~optical_properties.f90 sourcefile~photon_class.f90->sourcefile~vector_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sourceph.f90~~AfferentGraph sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules sourceph_mod Source Code sourceph.f90 Source Code module sourceph_mod !! Module contains the routines to inialise a photon, i.e different light sources. implicit none contains subroutine isotropic_point_src ( packet , grid ) !! set intial photon position at (0.0, 0.0, 0.0) and sample photon direction in an isotropic manner. use constants , only : TWOPI use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 !> photon object type ( photon ), intent ( out ) :: packet !> grid object type ( cart_grid ), intent ( in ) :: grid !set packet position packet % pos % z = 0.0 packet % pos % x = 0.0 packet % pos % y = 0.0 ! set packet cosines packet % phi = ran2 () * twoPI packet % cosp = cos ( packet % phi ) packet % sinp = sin ( packet % phi ) packet % cost = 2. * ran2 () - 1. packet % sint = sqrt ( 1. - packet % cost ** 2 ) ! set direction vector packet % dir % x = packet % sint * packet % cosp packet % dir % y = packet % sint * packet % sinp packet % dir % z = packet % cost ! set packet voxel packet % xcell = int ( grid % nxg * ( packet % pos % x + grid % dim % x ) / ( 2. * grid % dim % x )) + 1 packet % ycell = int ( grid % nyg * ( packet % pos % y + grid % dim % y ) / ( 2. * grid % dim % y )) + 1 packet % zcell = int ( grid % nzg * ( packet % pos % z + grid % dim % z ) / ( 2. * grid % dim % z )) + 1 packet % tflag = . false . end subroutine isotropic_point_src end module sourceph_mod","tags":"","loc":"sourcefile/sourceph.f90.html"},{"title":"optical_properties.f90 – gridMCRT","text":"Files dependent on this one sourcefile~~optical_properties.f90~~AfferentGraph sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~optical_properties.f90 sourcefile~mcpolar.f90->sourcefile~gridset.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~photon_class.f90->sourcefile~optical_properties.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 sourcefile~writer.f90->sourcefile~gridset.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules optical_properties_class Source Code optical_properties.f90 Source Code module optical_properties_class !! Change optical properties !! Set the \\mu_s (scattering coefficient), \\mu_a(absorption coefficient) both in cm&#94;{-1}, and hgg (g factor). implicit none !> Stores the optical properties of the medium. Currently only 1 media type. Can expand by making these arrays. type :: optical_properties !> \\mu_s is the scattering coefficent. in cm&#94;{-1} real :: mus !> \\mu_a is the absorption coefficent. in cm&#94;{-1} real :: mua !> hgg is the g factor. Describes the bias of the scattering direction. 1 means forward, 0 isotropic and -1 backscattering. unitless real :: hgg !> Is the g factor squared real :: g2 !> \\kappa is \\mu_s + \\mu_a real :: kappa !> The albedo is \\frac{\\mu_s}{\\mu_a+\\mu_s} real :: albedo end type optical_properties private public :: optical_properties , init_opt_sphere , init_opt2 contains subroutine init_opt_sphere ( opt_prop ) !!  Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. !> optical property container type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.0d0 opt_prop % g2 = opt_prop % hgg ** 2. opt_prop % mua = 0.0 opt_prop % mus = 1 0.0 opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt_sphere subroutine init_opt2 ( opt_prop ) !!  Set tissue optical properties 420nm !> optical property container type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.9 opt_prop % g2 = opt_prop % hgg ** 2. opt_prop % mua = 1.8 opt_prop % mus = 8 2.0 / ( 1.0 - opt_prop % hgg ) opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt2 end module optical_properties_class","tags":"","loc":"sourcefile/optical_properties.f90.html"}]}