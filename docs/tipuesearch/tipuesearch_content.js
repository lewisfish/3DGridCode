var tipuesearch = {"pages":[{"title":" gridMCRT ","text":"gridMCRT Brief description License Brief description A Monte Carlo radiation transfer code with voxels representing the geometry, written in modern Fortran. License The gridMCRT source code and related files and documentation are distributed under a permissive free software license (MIT). Developer Info Lewis McMillan","tags":"home","loc":"index.html"},{"title":"photon – gridMCRT ","text":"type, public :: photon photon type. Encapsulates all information about a single photon. Inherits type~~photon~~InheritsGraph type~photon photon type~vector vector type~photon->type~vector dir, pos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables cosp cost dir phi pos sinp sint tflag xcell ycell zcell Type-Bound Procedures scatter Source Code photon Components Type Visibility Attributes Name Initial real, public :: cosp direction angles real, public :: cost direction angles type( vector ), public :: dir direction vector real, public :: phi direction angles type( vector ), public :: pos position vector real, public :: sinp direction angles real, public :: sint direction angles logical, public :: tflag Boolean flag that if true photon is alive and in the simulation integer, public :: xcell Current voxel which the photon is in integer, public :: ycell Current voxel which the photon is in integer, public :: zcell Current voxel which the photon is in Type-Bound Procedures procedure, public :: scatter public  subroutine scatter (this, opt_prop) photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0)\nadapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html Arguments Type Intent Optional Attributes Name class( photon ) :: this photon packet type( optical_properties ), intent(in) :: opt_prop optical properties Source Code type :: photon !> direction vector type ( vector ) :: dir !> position vector type ( vector ) :: pos !> direction angles real :: sint , cost , sinp , cosp , phi !> Boolean flag that if true photon is alive and in the simulation logical :: tflag !> Current voxel which the photon is in integer :: xcell , ycell , zcell contains procedure :: scatter end type photon","tags":"","loc":"type/photon.html"},{"title":"vector – gridMCRT ","text":"type, public :: vector Vector type used for direction and position vectors\nsupports all possible vector operations Inherited by type~~vector~~InheritedByGraph type~vector vector type~cart_grid cart_grid type~cart_grid->type~vector dim type~photon photon type~photon->type~vector dir, pos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables x y z Type-Bound Procedures magnitude operator(*) operator(+) operator(-) operator(.dot.) operator(/) print Source Code vector Components Type Visibility Attributes Name Initial real, public :: x components of the vector real, public :: y components of the vector real, public :: z components of the vector Type-Bound Procedures procedure, public :: magnitude => magnitude_fn get the magnitde of a vector private  function magnitude_fn(this) Arguments Type Intent Optional Attributes Name class( vector ) :: this Return Value type( vector ) generic, public :: operator(*) => vec_mult_vec, vec_mult_scal, scal_mult_vec multiple a vector by a scalar or vector (element wise) private  function vec_mult_vec(a, b) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) private  function vec_mult_scal(a, b) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) private  function scal_mult_vec(a, b) Arguments Type Intent Optional Attributes Name real, intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) generic, public :: operator(+) => vec_add_vec, vec_add_scal, scal_add_vec add two vectors, or a vector and a scalar private  function vec_add_vec(a, b) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) private  function vec_add_scal(a, b) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) private  function scal_add_vec(a, b) Arguments Type Intent Optional Attributes Name real, intent(in) :: a class( vector ), intent(in) :: b Return Value type( vector ) generic, public :: operator(-) => vec_minus_vec subtract a vector from a vector private  function vec_minus_vec(a, b) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value type( vector ) generic, public :: operator(.dot.) => vec_dot get the dot product of two vectors private elemental function vec_dot(a, b) result(dot) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a type( vector ), intent(in) :: b Return Value real generic, public :: operator(/) => vec_div_scal divide a vector by a float private  function vec_div_scal(a, b) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: a real, intent(in) :: b Return Value type( vector ) procedure, public :: print => print_sub print a vector private  subroutine print_sub(this) Arguments Type Intent Optional Attributes Name class( vector ) :: this Source Code type :: vector !> components of the vector real :: x , y , z contains !> get the magnitde of a vector procedure :: magnitude => magnitude_fn !> print a vector procedure :: print => print_sub !> get the dot product of two vectors generic :: operator (. dot .) => vec_dot !> divide a vector by a float generic :: operator ( / ) => vec_div_scal !> multiple a vector by a scalar or vector (element wise) generic :: operator ( * ) => vec_mult_vec , vec_mult_scal , scal_mult_vec !> add two vectors, or a vector and a scalar generic :: operator ( + ) => vec_add_vec , vec_add_scal , scal_add_vec !> subtract a vector from a vector generic :: operator ( - ) => vec_minus_vec procedure , pass ( a ), private :: vec_dot procedure , pass ( a ), private :: vec_div_scal procedure , pass ( a ), private :: vec_mult_vec procedure , pass ( a ), private :: vec_mult_scal procedure , pass ( b ), private :: scal_mult_vec procedure , pass ( a ), private :: vec_add_vec procedure , pass ( a ), private :: vec_add_scal procedure , pass ( b ), private :: scal_add_vec procedure , pass ( a ), private :: vec_minus_vec end type vector","tags":"","loc":"type/vector.html"},{"title":"optical_properties – gridMCRT ","text":"type, public :: optical_properties Contents Variables albedo g2 hgg kappa mua mus Source Code optical_properties Components Type Visibility Attributes Name Initial real, public :: albedo real, public :: g2 real, public :: hgg real, public :: kappa real, public :: mua real, public :: mus Source Code type :: optical_properties real :: mus , mua , hgg , g2 , kappa , albedo end type optical_properties","tags":"","loc":"type/optical_properties.html"},{"title":"cart_grid – gridMCRT ","text":"type, public :: cart_grid Inherits type~~cart_grid~~InheritsGraph type~cart_grid cart_grid type~vector vector type~cart_grid->type~vector dim Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables delta dim nxg nyg nzg xface yface zface Source Code cart_grid Components Type Visibility Attributes Name Initial real, public :: delta ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls type( vector ), public :: dim half size of grid in cm integer, public :: nxg Size of grid in voxels in each direction integer, public :: nyg Size of grid in voxels in each direction integer, public :: nzg Size of grid in voxels in each direction real, public, allocatable :: xface (:) Arrays that store the location of each grid cell(voxel) wall real, public, allocatable :: yface (:) Arrays that store the location of each grid cell(voxel) wall real, public, allocatable :: zface (:) Arrays that store the location of each grid cell(voxel) wall Source Code type :: cart_grid !> Size of grid in voxels in each direction integer :: nxg , nyg , nzg !> half size of grid in cm type ( vector ) :: dim !> Arrays that store the location of each grid cell(voxel) wall real , allocatable :: xface (:), yface (:), zface (:) !> ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls real :: delta end type cart_grid","tags":"","loc":"type/cart_grid.html"},{"title":"scatter – gridMCRT","text":"public  subroutine scatter(this, opt_prop) Uses constants random_mod optical_properties_class proc~~scatter~~UsesGraph proc~scatter scatter module~constants constants proc~scatter->module~constants module~optical_properties_class optical_properties_class proc~scatter->module~optical_properties_class module~random_mod random_mod proc~scatter->module~random_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0)\nadapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html Arguments Type Intent Optional Attributes Name class( photon ) :: this photon packet type( optical_properties ), intent(in) :: opt_prop optical properties Calls proc~~scatter~~CallsGraph proc~scatter scatter proc~ran2 ran2 proc~scatter->proc~ran2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code scatter Source Code subroutine scatter ( this , opt_prop ) !! photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0) !! adapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html use optical_properties_class , only : optical_properties use constants , only : PI , TWOPI use random_mod , only : ran2 !> photon packet class ( photon ) :: this !> optical properties type ( optical_properties ), intent ( in ) :: opt_prop real :: temp , uxx , uyy , uzz if ( opt_prop % hgg == 0.0 ) then !isotropic scattering this % cost = 2. * ran2 () - 1. else !henyey-greenstein scattering temp = ( 1.0 - opt_prop % g2 ) / ( 1.0 - opt_prop % hgg + 2. * opt_prop % hgg * ran2 ()) this % cost = ( 1.0 + opt_prop % g2 - temp ** 2 ) / ( 2. * opt_prop % hgg ) end if this % sint = sqrt ( 1. - this % cost ** 2 ) this % phi = TWOPI * ran2 () this % cosp = cos ( this % phi ) if ( this % phi < PI ) then this % sinp = sqrt ( 1. - this % cosp ** 2 ) else this % sinp = - sqrt ( 1. - this % cosp ** 2 ) end if if ( 1. - abs ( this % dir % z ) <= 1e-12 ) then ! near perpindicular uxx = this % sint * this % cosp uyy = this % sint * this % sinp uzz = sign ( this % cost , this % dir % z ) else temp = sqrt ( 1. - this % dir % z ** 2 ) uxx = this % sint * ( this % dir % x * this % dir % z * this % cosp - this % dir % y * this % sinp ) & / temp + this % dir % x * this % cost uyy = this % sint * ( this % dir % y * this % dir % z * this % cosp + this % dir % x * this % sinp ) & / temp + this % dir % y * this % cost uzz = - 1. * this % sint * this % cosp * temp + this % dir % z * this % cost end if this % dir % x = uxx this % dir % y = uyy this % dir % z = uzz end subroutine scatter","tags":"","loc":"proc/scatter.html"},{"title":"writer – gridMCRT","text":"public  subroutine writer(grid, nphotons) Uses constants gridset_mod proc~~writer~~UsesGraph proc~writer writer module~constants constants proc~writer->module~constants module~gridset_mod gridset_mod proc~writer->module~gridset_mod module~vector_class vector_class module~gridset_mod->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. subroutine to write out normalised fluence Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(in) :: grid grid integer, intent(in) :: nphotons number of photons to normalise by Called by proc~~writer~~CalledByGraph proc~writer writer program~mcpolar mcpolar program~mcpolar->proc~writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code writer Source Code subroutine writer ( grid , nphotons ) !! subroutine to write out normalised fluence use constants , only : fileplace use gridset_mod , only : cart_grid !> grid type ( cart_grid ), intent ( in ) :: grid !> number of photons to normalise by integer , intent ( in ) :: nphotons ! normalise fluence assuming power is 1W ! write out fluence end subroutine writer","tags":"","loc":"proc/writer.html"},{"title":"ran2 – gridMCRT","text":"public  function ran2() Wrapper function to fortran internal random number generator\nGenerates a random number in the range [0,1.) Arguments None Return Value real Called by proc~~ran2~~CalledByGraph proc~ran2 ran2 proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->proc~ran2 proc~ranu ranu proc~ranu->proc~ran2 proc~scatter scatter proc~scatter->proc~ran2 proc~tauint1 tauint1 proc~tauint1->proc~ran2 program~mcpolar mcpolar program~mcpolar->proc~ran2 program~mcpolar->proc~isotropic_point_src program~mcpolar->proc~tauint1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code ran2 Source Code real function ran2 () !! Wrapper function to fortran internal random number generator !! Generates a random number in the range [0,1.) call random_number ( ran2 ) end function ran2","tags":"","loc":"proc/ran2.html"},{"title":"ranu – gridMCRT","text":"public  function ranu(a, b) sample uniformly between [a, b] Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: b Return Value real Calls proc~~ranu~~CallsGraph proc~ranu ranu proc~ran2 ran2 proc~ranu->proc~ran2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code ranu Source Code real function ranu ( a , b ) !! sample uniformly between [a, b] real , intent ( IN ) :: a , b ranu = a + ran2 () * ( b - a ) end function ranu","tags":"","loc":"proc/ranu.html"},{"title":"init_seed – gridMCRT","text":"public  subroutine init_seed(seed) user convenience function for setting random generator seed Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed Called by proc~~init_seed~~CalledByGraph proc~init_seed init_seed program~mcpolar mcpolar program~mcpolar->proc~init_seed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code init_seed Source Code subroutine init_seed ( seed ) !! user convenience function for setting random generator seed integer , intent ( in ) :: seed integer :: n integer , allocatable :: iseed (:) ! get seed size call random_seed ( size = n ) allocate ( iseed ( n )) ! put user seed in actual seed iseed = seed ! seed the RNG call random_seed ( put = iseed ) end subroutine init_seed","tags":"","loc":"proc/init_seed.html"},{"title":"init_opt2 – gridMCRT","text":"public  subroutine init_opt2(opt_prop) Set tissue optical properties 420nm Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop Contents Source Code init_opt2 Source Code subroutine init_opt2 ( opt_prop ) !!  Set tissue optical properties 420nm type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.9 opt_prop % g2 = opt_prop % hgg ** 2. opt_prop % mua = 1.8 opt_prop % mus = 8 2.0 / ( 1.0 - opt_prop % hgg ) opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt2","tags":"","loc":"proc/init_opt2.html"},{"title":"init_opt_sphere – gridMCRT","text":"public  subroutine init_opt_sphere(opt_prop) Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop Called by proc~~init_opt_sphere~~CalledByGraph proc~init_opt_sphere init_opt_sphere program~mcpolar mcpolar program~mcpolar->proc~init_opt_sphere Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code init_opt_sphere Source Code subroutine init_opt_sphere ( opt_prop ) !!  Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.0d0 opt_prop % g2 = opt_prop % hgg ** 2. opt_prop % mua = 0.0 opt_prop % mus = 1 0.0 opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt_sphere","tags":"","loc":"proc/init_opt_sphere.html"},{"title":"tauint1 – gridMCRT","text":"public  subroutine tauint1(packet, grid) Uses random_mod vector_class gridset_mod iarray photon_class proc~~tauint1~~UsesGraph proc~tauint1 tauint1 module~gridset_mod gridset_mod proc~tauint1->module~gridset_mod module~iarray iarray proc~tauint1->module~iarray module~photon_class photon_class proc~tauint1->module~photon_class module~random_mod random_mod proc~tauint1->module~random_mod module~vector_class vector_class proc~tauint1->module~vector_class module~gridset_mod->module~vector_class module~photon_class->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. optical depth integration subroutine. The main workhorse of MCRT Arguments Type Intent Optional Attributes Name type( photon ), intent(inout) :: packet packet to move through the grid type( cart_grid ), intent(in) :: grid grid that the packet moves through Calls proc~~tauint1~~CallsGraph proc~tauint1 tauint1 proc~ran2 ran2 proc~tauint1->proc~ran2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~tauint1~~CalledByGraph proc~tauint1 tauint1 program~mcpolar mcpolar program~mcpolar->proc~tauint1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code tauint1 Source Code subroutine tauint1 ( packet , grid ) !! optical depth integration subroutine. The main workhorse of MCRT use gridset_mod , only : cart_grid use iarray , only : rhokap use photon_class , only : photon use random_mod , only : ran2 use vector_class , only : vector !> packet to move through the grid type ( photon ), intent ( inout ) :: packet !> grid that the packet moves through type ( cart_grid ), intent ( in ) :: grid ! intermediate position type ( vector ) :: pos real :: tau , taurun , taucell , d , dcell integer :: celli , cellj , cellk logical :: dir ( 3 ) !change grid origin to lower left of the grid pos = packet % pos + grid % dim ! store current voxel in temp variables celli = packet % xcell cellj = packet % ycell cellk = packet % zcell ! setup to start integrating taurun = 0. d = 0. dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !sample optical distance tau = - log ( ran2 ()) do dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !get distance to nearest wall in direction dir dcell = wall_dist ( packet , grid , celli , cellj , cellk , pos , dir ) !calculate optical distnace to cell wall taucell = dcell * rhokap ( celli , cellj , cellk ) if ( taurun + taucell < tau ) then !still some tau to move taurun = taurun + taucell d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . TRUE ., dir ) else !moved full distance dcell = ( tau - taurun ) / rhokap ( celli , cellj , cellk ) d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . FALSE ., dir ) exit end if if ( celli == - 1 . or . cellj == - 1 . or . cellk == - 1 ) then packet % tflag = . true . exit end if end do ! move back to grid with origin at the centre packet % pos = pos - grid % dim packet % xcell = celli packet % ycell = cellj packet % zcell = cellk end subroutine tauint1","tags":"","loc":"proc/tauint1.html"},{"title":"gridset – gridMCRT","text":"public  subroutine gridset(grid, opt_prop, nxg, nyg, nzg, xmax, ymax, zmax) Uses optical_properties_class iarray proc~~gridset~~UsesGraph proc~gridset gridset module~iarray iarray proc~gridset->module~iarray module~optical_properties_class optical_properties_class proc~gridset->module~optical_properties_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Set up grids and create geometry Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(out) :: grid cart_grid varible is assigned in this routine type( optical_properties ), intent(in) :: opt_prop integer, intent(in) :: nxg integer, intent(in) :: nyg integer, intent(in) :: nzg real, intent(in) :: xmax real, intent(in) :: ymax real, intent(in) :: zmax Called by proc~~gridset~~CalledByGraph proc~gridset gridset program~mcpolar mcpolar program~mcpolar->proc~gridset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code gridset Source Code subroutine gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) !! Set up grids and create geometry use iarray , only : rhokap , rhokap use optical_properties_class , only : optical_properties !> cart_grid varible is assigned in this routine type ( cart_grid ), intent ( out ) :: grid type ( optical_properties ), intent ( in ) :: opt_prop integer , intent ( in ) :: nxg , nyg , nzg real , intent ( in ) :: xmax , ymax , zmax integer :: i , j , k real :: x , y , z , taueq1 , taupole1 , taueq2 , taupole2 print * , ' ' print * , 'Setting up grid....' ! set grid dimensions and voxel numbers grid % dim = vector ( xmax , ymax , zmax ) grid % nxg = nxg grid % nyg = nyg grid % nzg = nzg ! Set small distance for use in optical depth integration routines ! for roundoff effects when crossing cell walls grid % delta = 1.e-8 * ( 2. * grid % dim % z / grid % nzg ) ! allocate and set arrays to 0 call alloc_array ( grid ) call zarray ( grid ) ! setup grid cell walls do i = 1 , grid % nxg + 1 grid % xface ( i ) = ( i - 1 ) * 2. * grid % dim % x / grid % nxg end do do i = 1 , grid % nyg + 1 grid % yface ( i ) = ( i - 1 ) * 2. * grid % dim % y / grid % nyg end do do i = 1 , grid % nzg + 1 grid % zface ( i ) = ( i - 1 ) * 2. * grid % dim % z / grid % nzg end do !set up optical properties grid do i = 1 , grid % nxg x = grid % xface ( i ) - grid % dim % x + grid % dim % x / grid % nxg do j = 1 , grid % nyg y = grid % yface ( j ) - grid % dim % y + grid % dim % y / grid % nyg do k = 1 , grid % nzg z = grid % zface ( k ) - grid % dim % z + grid % dim % z / grid % nzg ! create a sphere of radius 1. if ( sqrt ( x ** 2 + y ** 2 + z ** 2 ) <= 1. ) then rhokap ( i , j , k ) = opt_prop % kappa else rhokap ( i , j , k ) = 0. end if end do end do end do ! Calculate equatorial and polar optical depths taueq1 = 0. taupole1 = 0. taueq2 = 0. taupole2 = 0. do i = 1 , grid % nxg taueq1 = taueq1 + rhokap ( i , grid % nyg / 2 , grid % nzg / 2 ) end do do i = 1 , grid % nzg taupole1 = taupole1 + rhokap ( grid % nxg / 2 , grid % nyg / 2 , i ) end do taueq1 = taueq1 * 2. * grid % dim % x / grid % nxg taupole1 = taupole1 * 2. * grid % dim % z / grid % nzg print '(A,F9.5,A,F9.5)' , ' taueq1 = ' , taueq1 , '  taupole1 = ' , taupole1 end subroutine gridset","tags":"","loc":"proc/gridset.html"},{"title":"isotropic_point_src – gridMCRT","text":"public  subroutine isotropic_point_src(packet, grid) Uses constants random_mod gridset_mod photon_class proc~~isotropic_point_src~~UsesGraph proc~isotropic_point_src isotropic_point_src module~constants constants proc~isotropic_point_src->module~constants module~gridset_mod gridset_mod proc~isotropic_point_src->module~gridset_mod module~photon_class photon_class proc~isotropic_point_src->module~photon_class module~random_mod random_mod proc~isotropic_point_src->module~random_mod module~vector_class vector_class module~gridset_mod->module~vector_class module~photon_class->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. set intial photon position Arguments Type Intent Optional Attributes Name type( photon ), intent(out) :: packet photon object type( cart_grid ), intent(in) :: grid grid object Calls proc~~isotropic_point_src~~CallsGraph proc~isotropic_point_src isotropic_point_src proc~ran2 ran2 proc~isotropic_point_src->proc~ran2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~isotropic_point_src~~CalledByGraph proc~isotropic_point_src isotropic_point_src program~mcpolar mcpolar program~mcpolar->proc~isotropic_point_src Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code isotropic_point_src Source Code subroutine isotropic_point_src ( packet , grid ) !! set intial photon position use constants , only : TWOPI use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 !> photon object type ( photon ), intent ( out ) :: packet !> grid object type ( cart_grid ), intent ( in ) :: grid !set packet position packet % pos % z = 0.0 packet % pos % x = 0.0 packet % pos % y = 0.0 ! set packet cosines packet % phi = ran2 () * twoPI packet % cosp = cos ( packet % phi ) packet % sinp = sin ( packet % phi ) packet % cost = 2. * ran2 () - 1. packet % sint = sqrt ( 1. - packet % cost ** 2 ) ! set direction vector packet % dir % x = packet % sint * packet % cosp packet % dir % y = packet % sint * packet % sinp packet % dir % z = packet % cost ! set packet voxel packet % xcell = int ( grid % nxg * ( packet % pos % x + grid % dim % x ) / ( 2. * grid % dim % x )) + 1 packet % ycell = int ( grid % nyg * ( packet % pos % y + grid % dim % y ) / ( 2. * grid % dim % y )) + 1 packet % zcell = int ( grid % nzg * ( packet % pos % z + grid % dim % z ) / ( 2. * grid % dim % z )) + 1 packet % tflag = . false . end subroutine isotropic_point_src","tags":"","loc":"proc/isotropic_point_src.html"},{"title":"chdir – gridMCRT","text":"public  subroutine chdir(path, error) Uses iso_c_binding proc~~chdir~~UsesGraph proc~chdir chdir iso_c_binding iso_c_binding proc~chdir->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. change current directory via c-lib call Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path integer, intent(out), optional :: error Calls proc~~chdir~~CallsGraph proc~chdir chdir interface~c_chdir c_chdir proc~chdir->interface~c_chdir Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code chdir Source Code subroutine chdir ( path , error ) !! change current directory via c-lib call use iso_c_binding , only : c_null_char character ( * ), intent ( IN ) :: path integer , optional , intent ( OUT ) :: error integer :: err err = c_chdir ( trim ( path ) // c_null_char ) if ( present ( error )) error = err end subroutine chdir","tags":"","loc":"proc/chdir.html"},{"title":"set_directories – gridMCRT","text":"public  subroutine set_directories() Uses constants proc~~set_directories~~UsesGraph proc~set_directories set_directories module~constants constants proc~set_directories->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. define variables to hold paths to various folders Arguments None Called by proc~~set_directories~~CalledByGraph proc~set_directories set_directories program~mcpolar mcpolar program~mcpolar->proc~set_directories Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code set_directories Source Code subroutine set_directories () !! define variables to hold paths to various folders use constants , only : cwd , homedir , fileplace , resdir !get current working directory call get_environment_variable ( 'PWD' , cwd ) ! get 'home' dir from cwd if ( index ( cwd , \"bin\" ) > 0 ) then ! if program is run from bin dir homedir = trim ( cwd ( 1 : len ( trim ( cwd )) - 3 )) else ! program is run from root dir homedir = trim ( cwd ) // \"/\" end if ! get data dir fileplace = trim ( homedir ) // 'data/' ! get res dir resdir = trim ( homedir ) // 'res/' end subroutine set_directories","tags":"","loc":"proc/set_directories.html"},{"title":"c_chdir – gridMCRT","text":"interface change current directory Called by interface~~c_chdir~~CalledByGraph interface~c_chdir c_chdir proc~chdir chdir proc~chdir->interface~c_chdir Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function c_chdir(path) bind(C, name=\"chdir\") Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), intent(in) :: path (*) Return Value integer(kind=C_int)","tags":"","loc":"interface/c_chdir.html"},{"title":"str – gridMCRT","text":"public interface str functions to turn numerical variables into strings Called by interface~~str~~CalledByGraph interface~str str program~mcpolar mcpolar program~mcpolar->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures str_I32 str_I64 str_Iarray str_R8 str_R8array str_logicalarray Module Procedures private  function str_I32(i) convert an int32 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable private  function str_I64(i) convert an int64 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: i Return Value character(len=:), allocatable private  function str_iarray(i) convert an int32 integer array into a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) Return Value character(len=:), allocatable private  function str_R8(i) convert an double precision float into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: i Return Value character(len=:), allocatable private  function str_R8array(a) convert an double precision float array into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (:) Return Value character(len=:), allocatable private  function str_logicalarray(a) convert an logical array into a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: a (:) Return Value character(len=:), allocatable","tags":"","loc":"interface/str.html"},{"title":"swap – gridMCRT","text":"public interface swap subroutines to swap numerical variables Contents Module Procedures swap_I swap_R8 Module Procedures private  subroutine swap_I(a, b) swap two integer variables Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b private  subroutine swap_R8(a, b) swap double precision variables Arguments Type Intent Optional Attributes Name double precision, intent(inout) :: a double precision, intent(inout) :: b","tags":"","loc":"interface/swap.html"},{"title":"photon_class – gridMCRT","text":"Module defines the photon class and scattering routines Uses vector_class module~~photon_class~~UsesGraph module~photon_class photon_class module~vector_class vector_class module~photon_class->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~photon_class~~UsedByGraph module~photon_class photon_class proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->module~photon_class proc~tauint1 tauint1 proc~tauint1->module~photon_class program~mcpolar mcpolar program~mcpolar->module~photon_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types photon Subroutines scatter Derived Types type, public :: photon photon type. Encapsulates all information about a single photon. Components Type Visibility Attributes Name Initial real, public :: cosp direction angles real, public :: cost direction angles type( vector ), public :: dir direction vector real, public :: phi direction angles type( vector ), public :: pos position vector real, public :: sinp direction angles real, public :: sint direction angles logical, public :: tflag Boolean flag that if true photon is alive and in the simulation integer, public :: xcell Current voxel which the photon is in integer, public :: ycell Current voxel which the photon is in integer, public :: zcell Current voxel which the photon is in Type-Bound Procedures procedure\n                    ,                  public\n                  :: scatter Subroutine Subroutines public  subroutine scatter (this, opt_prop) photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0)\nadapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html Arguments Type Intent Optional Attributes Name class( photon ) :: this photon packet type( optical_properties ), intent(in) :: opt_prop optical properties","tags":"","loc":"module/photon_class.html"},{"title":"vector_class – gridMCRT","text":"Module contains the vector class and associated routines. Used by module~~vector_class~~UsedByGraph module~vector_class vector_class module~gridset_mod gridset_mod module~gridset_mod->module~vector_class module~photon_class photon_class module~photon_class->module~vector_class proc~tauint1 tauint1 proc~tauint1->module~vector_class proc~tauint1->module~gridset_mod proc~tauint1->module~photon_class proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->module~gridset_mod proc~isotropic_point_src->module~photon_class proc~writer writer proc~writer->module~gridset_mod program~mcpolar mcpolar program~mcpolar->module~gridset_mod program~mcpolar->module~photon_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types vector Derived Types type, public :: vector Vector type used for direction and position vectors\nsupports all possible vector operations Components Type Visibility Attributes Name Initial real, public :: x components of the vector real, public :: y components of the vector real, public :: z components of the vector Type-Bound Procedures procedure\n                    ,                  public\n                  :: magnitude =>\n                    magnitude_fn Function get the magnitde of a vector generic,\n                  public\n                  :: operator(*) =>\n                    vec_mult_vec, vec_mult_scal, scal_mult_vec multiple a vector by a scalar or vector (element wise) generic,\n                  public\n                  :: operator(+) =>\n                    vec_add_vec, vec_add_scal, scal_add_vec add two vectors, or a vector and a scalar generic,\n                  public\n                  :: operator(-) =>\n                    vec_minus_vec subtract a vector from a vector generic,\n                  public\n                  :: operator(.dot.) =>\n                    vec_dot get the dot product of two vectors generic,\n                  public\n                  :: operator(/) =>\n                    vec_div_scal divide a vector by a float procedure\n                    ,                  public\n                  :: print =>\n                    print_sub Subroutine print a vector","tags":"","loc":"module/vector_class.html"},{"title":"writer_mod – gridMCRT","text":"I/O related routines. Used by module~~writer_mod~~UsedByGraph module~writer_mod writer_mod program~mcpolar mcpolar program~mcpolar->module~writer_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines writer Subroutines public  subroutine writer (grid, nphotons) subroutine to write out normalised fluence Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(in) :: grid grid integer, intent(in) :: nphotons number of photons to normalise by","tags":"","loc":"module/writer_mod.html"},{"title":"random_mod – gridMCRT","text":"module containg routines related to random numbers Used by module~~random_mod~~UsedByGraph module~random_mod random_mod proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->module~random_mod proc~scatter scatter proc~scatter->module~random_mod proc~tauint1 tauint1 proc~tauint1->module~random_mod program~mcpolar mcpolar program~mcpolar->module~random_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions ran2 ranu Subroutines init_seed Functions public  function ran2 () Wrapper function to fortran internal random number generator\nGenerates a random number in the range [0,1.) Arguments None Return Value real public  function ranu (a, b) sample uniformly between [a, b] Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: b Return Value real Subroutines public  subroutine init_seed (seed) user convenience function for setting random generator seed Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed","tags":"","loc":"module/random_mod.html"},{"title":"optical_properties_class – gridMCRT","text":"Change optical properties\nSet the (scattering coefficient), (absorption coefficient) both in cm , and hgg (g factor). Used by module~~optical_properties_class~~UsedByGraph module~optical_properties_class optical_properties_class proc~gridset gridset proc~gridset->module~optical_properties_class proc~scatter scatter proc~scatter->module~optical_properties_class program~mcpolar mcpolar program~mcpolar->module~optical_properties_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types optical_properties Subroutines init_opt2 init_opt_sphere Derived Types type, public :: optical_properties Components Type Visibility Attributes Name Initial real, public :: albedo real, public :: g2 real, public :: hgg real, public :: kappa real, public :: mua real, public :: mus Subroutines public  subroutine init_opt2 (opt_prop) Set tissue optical properties 420nm Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop public  subroutine init_opt_sphere (opt_prop) Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. Arguments Type Intent Optional Attributes Name type( optical_properties ), intent(out) :: opt_prop","tags":"","loc":"module/optical_properties_class.html"},{"title":"iarray – gridMCRT","text":"Contains all array variable names. Used by module~~iarray~~UsedByGraph module~iarray iarray proc~gridset gridset proc~gridset->module~iarray proc~tauint1 tauint1 proc~tauint1->module~iarray Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables rhokap Variables Type Visibility Attributes Name Initial real, public, allocatable :: rhokap (:,:,:) stores the optical properties, i.e the total cross section","tags":"","loc":"module/iarray.html"},{"title":"inttau2 – gridMCRT","text":"module contains routines related to the optical depth integration of a photon though a 3D grid. Used by module~~inttau2~~UsedByGraph module~inttau2 inttau2 program~mcpolar mcpolar program~mcpolar->module~inttau2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines tauint1 Subroutines public  subroutine tauint1 (packet, grid) optical depth integration subroutine. The main workhorse of MCRT Arguments Type Intent Optional Attributes Name type( photon ), intent(inout) :: packet packet to move through the grid type( cart_grid ), intent(in) :: grid grid that the packet moves through","tags":"","loc":"module/inttau2.html"},{"title":"gridset_mod – gridMCRT","text":"Module provides a cartesian grid type to store all grid related variables in a container\nAlso provides a way of setting up the geomerty/grid for the simulation. Uses vector_class module~~gridset_mod~~UsesGraph module~gridset_mod gridset_mod module~vector_class vector_class module~gridset_mod->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~gridset_mod~~UsedByGraph module~gridset_mod gridset_mod proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->module~gridset_mod proc~tauint1 tauint1 proc~tauint1->module~gridset_mod proc~writer writer proc~writer->module~gridset_mod program~mcpolar mcpolar program~mcpolar->module~gridset_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Derived Types cart_grid Subroutines gridset Derived Types type, public :: cart_grid Components Type Visibility Attributes Name Initial real, public :: delta ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls type( vector ), public :: dim half size of grid in cm integer, public :: nxg Size of grid in voxels in each direction integer, public :: nyg Size of grid in voxels in each direction integer, public :: nzg Size of grid in voxels in each direction real, public, allocatable :: xface (:) Arrays that store the location of each grid cell(voxel) wall real, public, allocatable :: yface (:) Arrays that store the location of each grid cell(voxel) wall real, public, allocatable :: zface (:) Arrays that store the location of each grid cell(voxel) wall Subroutines public  subroutine gridset (grid, opt_prop, nxg, nyg, nzg, xmax, ymax, zmax) Set up grids and create geometry Arguments Type Intent Optional Attributes Name type( cart_grid ), intent(out) :: grid cart_grid varible is assigned in this routine type( optical_properties ), intent(in) :: opt_prop integer, intent(in) :: nxg integer, intent(in) :: nyg integer, intent(in) :: nzg real, intent(in) :: xmax real, intent(in) :: ymax real, intent(in) :: zmax","tags":"","loc":"module/gridset_mod.html"},{"title":"sourceph_mod – gridMCRT","text":"Module contains the routines to inialise a photon, i.e different light sources. Used by module~~sourceph_mod~~UsedByGraph module~sourceph_mod sourceph_mod program~mcpolar mcpolar program~mcpolar->module~sourceph_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines isotropic_point_src Subroutines public  subroutine isotropic_point_src (packet, grid) set intial photon position Arguments Type Intent Optional Attributes Name type( photon ), intent(out) :: packet photon object type( cart_grid ), intent(in) :: grid grid object","tags":"","loc":"module/sourceph_mod.html"},{"title":"utils – gridMCRT","text":"module that contains utility functions and helper routines. Used by module~~utils~~UsedByGraph module~utils utils program~mcpolar mcpolar program~mcpolar->module~utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces c_chdir str swap Subroutines chdir set_directories Interfaces interface change current directory public  function c_chdir(path) bind(C, name=\"chdir\") Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), intent(in) :: path (*) Return Value integer(kind=C_int) public        interface str functions to turn numerical variables into strings private  function str_I32(i) convert an int32 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable private  function str_I64(i) convert an int64 integer into a string Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: i Return Value character(len=:), allocatable private  function str_iarray(i) convert an int32 integer array into a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i (:) Return Value character(len=:), allocatable private  function str_R8(i) convert an double precision float into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: i Return Value character(len=:), allocatable private  function str_R8array(a) convert an double precision float array into a string Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (:) Return Value character(len=:), allocatable private  function str_logicalarray(a) convert an logical array into a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: a (:) Return Value character(len=:), allocatable public        interface swap subroutines to swap numerical variables private  subroutine swap_I(a, b) swap two integer variables Arguments Type Intent Optional Attributes Name integer, intent(inout) :: a integer, intent(inout) :: b private  subroutine swap_R8(a, b) swap double precision variables Arguments Type Intent Optional Attributes Name double precision, intent(inout) :: a double precision, intent(inout) :: b Subroutines public  subroutine chdir (path, error) change current directory via c-lib call Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path integer, intent(out), optional :: error public  subroutine set_directories () define variables to hold paths to various folders Arguments None","tags":"","loc":"module/utils.html"},{"title":"constants – gridMCRT","text":"Constants used throughout the simulation. Used by module~~constants~~UsedByGraph module~constants constants proc~isotropic_point_src isotropic_point_src proc~isotropic_point_src->module~constants proc~scatter scatter proc~scatter->module~constants proc~set_directories set_directories proc~set_directories->module~constants proc~writer writer proc~writer->module~constants program~mcpolar mcpolar program~mcpolar->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables PI TWOPI cwd fileplace homedir resdir Variables Type Visibility Attributes Name Initial real, public, parameter :: PI = 4.*atan(1.) mathematical constants real, public, parameter :: TWOPI = 2.*PI mathematical constants character(len=255), public :: cwd variables that store directories for files etc character(len=255), public :: fileplace variables that store directories for files etc character(len=255), public :: homedir variables that store directories for files etc character(len=255), public :: resdir variables that store directories for files etc","tags":"","loc":"module/constants.html"},{"title":"mcpolar – gridMCRT","text":"Uses constants optical_properties_class writer_mod inttau2 random_mod utils gridset_mod sourceph_mod photon_class program~~mcpolar~~UsesGraph program~mcpolar mcpolar module~constants constants program~mcpolar->module~constants module~gridset_mod gridset_mod program~mcpolar->module~gridset_mod module~inttau2 inttau2 program~mcpolar->module~inttau2 module~optical_properties_class optical_properties_class program~mcpolar->module~optical_properties_class module~photon_class photon_class program~mcpolar->module~photon_class module~random_mod random_mod program~mcpolar->module~random_mod module~sourceph_mod sourceph_mod program~mcpolar->module~sourceph_mod module~utils utils program~mcpolar->module~utils module~writer_mod writer_mod program~mcpolar->module~writer_mod module~vector_class vector_class module~gridset_mod->module~vector_class module~photon_class->module~vector_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~mcpolar~~CallsGraph program~mcpolar mcpolar interface~str str program~mcpolar->interface~str proc~gridset gridset program~mcpolar->proc~gridset proc~init_opt_sphere init_opt_sphere program~mcpolar->proc~init_opt_sphere proc~init_seed init_seed program~mcpolar->proc~init_seed proc~isotropic_point_src isotropic_point_src program~mcpolar->proc~isotropic_point_src proc~ran2 ran2 program~mcpolar->proc~ran2 proc~set_directories set_directories program~mcpolar->proc~set_directories proc~tauint1 tauint1 program~mcpolar->proc~tauint1 proc~writer writer program~mcpolar->proc~writer proc~isotropic_point_src->proc~ran2 proc~tauint1->proc~ran2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Variables finish grid j nphotons nscatt nxg nyg nzg opt_prop packet ran seed start u xmax ymax zmax Source Code mcpolar Variables Type Attributes Name Initial real :: finish timing vars type( cart_grid ) :: grid variable that holds the 3D grid information integer :: j temp variable or related to I/O from param file integer :: nphotons number of photons to run in the simulation double precision :: nscatt counter for number of scatterings for all photons integer :: nxg temp variable or related to I/O from param file integer :: nyg temp variable or related to I/O from param file integer :: nzg temp variable or related to I/O from param file type( optical_properties ) :: opt_prop optical properties variable type( photon ) :: packet variable that holds all information about the photon to be simulated real :: ran integer :: seed user defined seed real :: start timing vars integer :: u temp variable or related to I/O from param file real :: xmax real :: ymax real :: zmax Source Code program mcpolar !imports use constants , only : resdir use gridset_mod , only : gridset , cart_grid use inttau2 , only : tauint1 use optical_properties_class , only : optical_properties , init_opt_sphere use photon_class , only : photon use random_mod , only : ran2 , init_seed use sourceph_mod , only : isotropic_point_src use utils , only : set_directories , str use writer_mod , only : writer implicit none !> variable that holds all information about the photon to be simulated type ( photon ) :: packet !> variable that holds the 3D grid information type ( cart_grid ) :: grid !> optical properties variable type ( optical_properties ) :: opt_prop !> number of photons to run in the simulation integer :: nphotons !> counter for number of scatterings for all photons double precision :: nscatt !> user defined seed integer :: seed !> temp variable or related to I/O from param file integer :: nxg , nyg , nzg , j , u real :: xmax , ymax , zmax , ran !> timing vars real :: start , finish call cpu_time ( start ) !set directory paths call set_directories () !set optical properties call init_opt_sphere ( opt_prop ) !set random seed seed = 42 call init_seed ( seed ) !**** Read in parameters from the file input.params open ( newunit = u , file = trim ( resdir ) // 'input.params' , status = 'old' ) read ( u , * ) nphotons read ( u , * ) xmax read ( u , * ) ymax read ( u , * ) zmax read ( u , * ) nxg read ( u , * ) nyg read ( u , * ) nzg close ( u ) print * , '' print * , '# of photons to run' , nphotons ! Set up grid call gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) ! inialise the number of scatterings counter nscatt = 0 print * , 'Photons now running' !loop over photons do j = 1 , nphotons !display progress if ( mod ( j , 10000 ) == 0 ) then print * , str ( j ) // ' scattered photons completed' end if ! Release photon from point source call isotropic_point_src ( packet , grid ) ! Find scattering location call tauint1 ( packet , grid ) ! Photon scatters in grid until it exits (tflag=TRUE) do while (. not . packet % tflag ) ran = ran2 () !interact with medium if ( ran < opt_prop % albedo ) then ! photon is scattered call packet % scatter ( opt_prop ) nscatt = nscatt + 1 else ! photon is absorbed packet % tflag = . true . exit end if ! Find next scattering location call tauint1 ( packet , grid ) end do end do ! end loop over nph photons print * , 'Average # of scatters per photon: ' // str ( nscatt / ( nphotons )) !write out files call writer ( grid , nphotons ) print * , 'write done' call cpu_time ( finish ) if ( finish - start >= 6 0. ) then print * , floor (( finish - start ) / 6 0. ) + mod ( finish - start , 6 0. ) / 10 0. else print * , 'time taken ~' // str ( floor ( finish - start / 6 0. )) // 's' end if end program mcpolar","tags":"","loc":"program/mcpolar.html"},{"title":"photon_class.f90 – gridMCRT","text":"This file depends on sourcefile~~photon_class.f90~~EfferentGraph sourcefile~photon_class.f90 photon_class.f90 sourcefile~constants.f90 constants.f90 sourcefile~photon_class.f90->sourcefile~constants.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~photon_class.f90->sourcefile~optical_properties.f90 sourcefile~random_mod.f90 random_mod.f90 sourcefile~photon_class.f90->sourcefile~random_mod.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~photon_class.f90->sourcefile~vector_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~photon_class.f90~~AfferentGraph sourcefile~photon_class.f90 photon_class.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules photon_class Source Code photon_class.f90 Source Code module photon_class !! Module defines the photon class and scattering routines use vector_class , only : vector implicit none !> photon type. Encapsulates all information about a single photon. type :: photon !> direction vector type ( vector ) :: dir !> position vector type ( vector ) :: pos !> direction angles real :: sint , cost , sinp , cosp , phi !> Boolean flag that if true photon is alive and in the simulation logical :: tflag !> Current voxel which the photon is in integer :: xcell , ycell , zcell contains procedure :: scatter end type photon contains subroutine scatter ( this , opt_prop ) !! photon scattering routine. Handles both isotropic (hgg=0) and henyey-greenstein scattering (hgg /=0) !! adapted from mcxyz https://omlc.org/software/mc/mcxyz/index.html use optical_properties_class , only : optical_properties use constants , only : PI , TWOPI use random_mod , only : ran2 !> photon packet class ( photon ) :: this !> optical properties type ( optical_properties ), intent ( in ) :: opt_prop real :: temp , uxx , uyy , uzz if ( opt_prop % hgg == 0.0 ) then !isotropic scattering this % cost = 2. * ran2 () - 1. else !henyey-greenstein scattering temp = ( 1.0 - opt_prop % g2 ) / ( 1.0 - opt_prop % hgg + 2. * opt_prop % hgg * ran2 ()) this % cost = ( 1.0 + opt_prop % g2 - temp ** 2 ) / ( 2. * opt_prop % hgg ) end if this % sint = sqrt ( 1. - this % cost ** 2 ) this % phi = TWOPI * ran2 () this % cosp = cos ( this % phi ) if ( this % phi < PI ) then this % sinp = sqrt ( 1. - this % cosp ** 2 ) else this % sinp = - sqrt ( 1. - this % cosp ** 2 ) end if if ( 1. - abs ( this % dir % z ) <= 1e-12 ) then ! near perpindicular uxx = this % sint * this % cosp uyy = this % sint * this % sinp uzz = sign ( this % cost , this % dir % z ) else temp = sqrt ( 1. - this % dir % z ** 2 ) uxx = this % sint * ( this % dir % x * this % dir % z * this % cosp - this % dir % y * this % sinp ) & / temp + this % dir % x * this % cost uyy = this % sint * ( this % dir % y * this % dir % z * this % cosp + this % dir % x * this % sinp ) & / temp + this % dir % y * this % cost uzz = - 1. * this % sint * this % cosp * temp + this % dir % z * this % cost end if this % dir % x = uxx this % dir % y = uyy this % dir % z = uzz end subroutine scatter end module photon_class","tags":"","loc":"sourcefile/photon_class.f90.html"},{"title":"vector_class.f90 – gridMCRT","text":"Files dependent on this one sourcefile~~vector_class.f90~~AfferentGraph sourcefile~vector_class.f90 vector_class.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~vector_class.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~photon_class.f90->sourcefile~vector_class.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~gridset.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 sourcefile~writer.f90->sourcefile~gridset.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules vector_class Source Code vector_class.f90 Source Code Module vector_class !! Module contains the vector class and associated routines. implicit none !> Vector type used for direction and position vectors !> supports all possible vector operations type :: vector !> components of the vector real :: x , y , z contains !> get the magnitde of a vector procedure :: magnitude => magnitude_fn !> print a vector procedure :: print => print_sub !> get the dot product of two vectors generic :: operator (. dot .) => vec_dot !> divide a vector by a float generic :: operator ( / ) => vec_div_scal !> multiple a vector by a scalar or vector (element wise) generic :: operator ( * ) => vec_mult_vec , vec_mult_scal , scal_mult_vec !> add two vectors, or a vector and a scalar generic :: operator ( + ) => vec_add_vec , vec_add_scal , scal_add_vec !> subtract a vector from a vector generic :: operator ( - ) => vec_minus_vec procedure , pass ( a ), private :: vec_dot procedure , pass ( a ), private :: vec_div_scal procedure , pass ( a ), private :: vec_mult_vec procedure , pass ( a ), private :: vec_mult_scal procedure , pass ( b ), private :: scal_mult_vec procedure , pass ( a ), private :: vec_add_vec procedure , pass ( a ), private :: vec_add_scal procedure , pass ( b ), private :: scal_add_vec procedure , pass ( a ), private :: vec_minus_vec end type vector private public :: vector contains type ( vector ) function vec_minus_vec ( a , b ) class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_minus_vec = vector ( a % x - b % x , a % y - b % y , a % z - b % z ) end function vec_minus_vec type ( vector ) function vec_add_scal ( a , b ) class ( vector ), intent ( IN ) :: a real , intent ( IN ) :: b vec_add_scal = vector ( a % x + b , a % y + b , a % z + b ) end function vec_add_scal type ( vector ) function scal_add_vec ( a , b ) class ( vector ), intent ( IN ) :: b real , intent ( IN ) :: a scal_add_vec = vector ( b % x + a , b % y + a , b % z + a ) end function scal_add_vec type ( vector ) function vec_add_vec ( a , b ) class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_add_vec = vector ( a % x + b % x , a % y + b % y , a % z + b % z ) end function vec_add_vec elemental function vec_dot ( a , b ) result ( dot ) class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b real :: dot dot = ( a % x * b % x ) + ( a % y * b % y ) + ( a % z * b % z ) end function vec_dot type ( vector ) function vec_mult_vec ( a , b ) class ( vector ), intent ( IN ) :: a type ( vector ), intent ( IN ) :: b vec_mult_vec = vector ( a % x * b % x , a % y * b % y , a % z * b % z ) end function vec_mult_vec type ( vector ) function vec_mult_scal ( a , b ) class ( vector ), intent ( IN ) :: a real , intent ( IN ) :: b vec_mult_scal = vector ( a % x * b , a % y * b , a % z * b ) end function vec_mult_scal type ( vector ) function scal_mult_vec ( a , b ) class ( vector ), intent ( IN ) :: b real , intent ( IN ) :: a scal_mult_vec = vector ( a * b % x , a * b % y , a * b % z ) end function scal_mult_vec type ( vector ) function vec_div_scal ( a , b ) class ( vector ), intent ( IN ) :: a real , intent ( IN ) :: b vec_div_scal = vector ( a % x / b , a % y / b , a % z / b ) end function vec_div_scal type ( vector ) function magnitude_fn ( this ) class ( vector ) :: this real :: tmp tmp = sqrt ( this % x ** 2 + this % y ** 2 + this % z ** 2 ) magnitude_fn = this / tmp end function magnitude_fn subroutine print_sub ( this ) class ( vector ) :: this print * , this % x , this % y , this % z end subroutine end Module vector_class","tags":"","loc":"sourcefile/vector_class.f90.html"},{"title":"writer.f90 – gridMCRT","text":"This file depends on sourcefile~~writer.f90~~EfferentGraph sourcefile~writer.f90 writer.f90 sourcefile~constants.f90 constants.f90 sourcefile~writer.f90->sourcefile~constants.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~writer.f90->sourcefile~gridset.f90 sourcefile~iarray.f90 iarray.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~writer.f90~~AfferentGraph sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules writer_mod Source Code writer.f90 Source Code module writer_mod !! I/O related routines. implicit none contains subroutine writer ( grid , nphotons ) !! subroutine to write out normalised fluence use constants , only : fileplace use gridset_mod , only : cart_grid !> grid type ( cart_grid ), intent ( in ) :: grid !> number of photons to normalise by integer , intent ( in ) :: nphotons ! normalise fluence assuming power is 1W ! write out fluence end subroutine writer end module writer_mod","tags":"","loc":"sourcefile/writer.f90.html"},{"title":"random_mod.f90 – gridMCRT","text":"Files dependent on this one sourcefile~~random_mod.f90~~AfferentGraph sourcefile~random_mod.f90 random_mod.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~random_mod.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~random_mod.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~photon_class.f90->sourcefile~random_mod.f90 sourcefile~sourceph.f90->sourcefile~random_mod.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules random_mod Source Code random_mod.f90 Source Code module random_mod !! module containg routines related to random numbers implicit none private public :: ran2 , ranu , init_seed contains subroutine init_seed ( seed ) !! user convenience function for setting random generator seed integer , intent ( in ) :: seed integer :: n integer , allocatable :: iseed (:) ! get seed size call random_seed ( size = n ) allocate ( iseed ( n )) ! put user seed in actual seed iseed = seed ! seed the RNG call random_seed ( put = iseed ) end subroutine init_seed real function ran2 () !! Wrapper function to fortran internal random number generator !! Generates a random number in the range [0,1.) call random_number ( ran2 ) end function ran2 real function ranu ( a , b ) !! sample uniformly between [a, b] real , intent ( IN ) :: a , b ranu = a + ran2 () * ( b - a ) end function ranu end module random_mod","tags":"","loc":"sourcefile/random_mod.f90.html"},{"title":"optical_properties.f90 – gridMCRT","text":"Files dependent on this one sourcefile~~optical_properties.f90~~AfferentGraph sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~optical_properties.f90 sourcefile~mcpolar.f90->sourcefile~gridset.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~photon_class.f90->sourcefile~optical_properties.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 sourcefile~writer.f90->sourcefile~gridset.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules optical_properties_class Source Code optical_properties.f90 Source Code module optical_properties_class !! Change optical properties !! Set the \\mu_s (scattering coefficient), \\mu_a(absorption coefficient) both in cm&#94;{-1}, and hgg (g factor). implicit none type :: optical_properties real :: mus , mua , hgg , g2 , kappa , albedo end type optical_properties private public :: optical_properties , init_opt_sphere , init_opt2 contains subroutine init_opt_sphere ( opt_prop ) !!  Set tissue optical properties so that total optical depth in a sphere of radius 1cm is 10. type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.0d0 opt_prop % g2 = opt_prop % hgg ** 2. opt_prop % mua = 0.0 opt_prop % mus = 1 0.0 opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt_sphere subroutine init_opt2 ( opt_prop ) !!  Set tissue optical properties 420nm type ( optical_properties ), intent ( out ) :: opt_prop opt_prop % hgg = 0.9 opt_prop % g2 = opt_prop % hgg ** 2. opt_prop % mua = 1.8 opt_prop % mus = 8 2.0 / ( 1.0 - opt_prop % hgg ) opt_prop % kappa = opt_prop % mus + opt_prop % mua opt_prop % albedo = opt_prop % mus / opt_prop % kappa end subroutine init_opt2 end module optical_properties_class","tags":"","loc":"sourcefile/optical_properties.f90.html"},{"title":"iarray.f90 – gridMCRT","text":"Files dependent on this one sourcefile~~iarray.f90~~AfferentGraph sourcefile~iarray.f90 iarray.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~iarray.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~gridset.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~writer.f90->sourcefile~gridset.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules iarray Source Code iarray.f90 Source Code module iarray !!  Contains all array variable names. implicit none !> stores the optical properties, i.e the total cross section \\mu_t = \\mu_s + \\mu_a real , allocatable :: rhokap (:,:,:) end module iarray","tags":"","loc":"sourcefile/iarray.f90.html"},{"title":"inttau2.f90 – gridMCRT","text":"This file depends on sourcefile~~inttau2.f90~~EfferentGraph sourcefile~inttau2.f90 inttau2.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~iarray.f90 iarray.f90 sourcefile~inttau2.f90->sourcefile~iarray.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~random_mod.f90 random_mod.f90 sourcefile~inttau2.f90->sourcefile~random_mod.f90 sourcefile~utils.f90 utils.f90 sourcefile~inttau2.f90->sourcefile~utils.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~inttau2.f90->sourcefile~vector_class.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~photon_class.f90->sourcefile~random_mod.f90 sourcefile~photon_class.f90->sourcefile~vector_class.f90 sourcefile~constants.f90 constants.f90 sourcefile~photon_class.f90->sourcefile~constants.f90 sourcefile~photon_class.f90->sourcefile~optical_properties.f90 sourcefile~utils.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~inttau2.f90~~AfferentGraph sourcefile~inttau2.f90 inttau2.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules inttau2 Source Code inttau2.f90 Source Code module inttau2 !! module contains routines related to the optical depth integration of a photon though a 3D grid. implicit none private public :: tauint1 CONTAINS subroutine tauint1 ( packet , grid ) !! optical depth integration subroutine. The main workhorse of MCRT use gridset_mod , only : cart_grid use iarray , only : rhokap use photon_class , only : photon use random_mod , only : ran2 use vector_class , only : vector !> packet to move through the grid type ( photon ), intent ( inout ) :: packet !> grid that the packet moves through type ( cart_grid ), intent ( in ) :: grid ! intermediate position type ( vector ) :: pos real :: tau , taurun , taucell , d , dcell integer :: celli , cellj , cellk logical :: dir ( 3 ) !change grid origin to lower left of the grid pos = packet % pos + grid % dim ! store current voxel in temp variables celli = packet % xcell cellj = packet % ycell cellk = packet % zcell ! setup to start integrating taurun = 0. d = 0. dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !sample optical distance tau = - log ( ran2 ()) do dir = ( / . FALSE ., . FALSE ., . FALSE . / ) !get distance to nearest wall in direction dir dcell = wall_dist ( packet , grid , celli , cellj , cellk , pos , dir ) !calculate optical distnace to cell wall taucell = dcell * rhokap ( celli , cellj , cellk ) if ( taurun + taucell < tau ) then !still some tau to move taurun = taurun + taucell d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . TRUE ., dir ) else !moved full distance dcell = ( tau - taurun ) / rhokap ( celli , cellj , cellk ) d = d + dcell call update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , . FALSE ., dir ) exit end if if ( celli == - 1 . or . cellj == - 1 . or . cellk == - 1 ) then packet % tflag = . true . exit end if end do ! move back to grid with origin at the centre packet % pos = pos - grid % dim packet % xcell = celli packet % ycell = cellj packet % zcell = cellk end subroutine tauint1 real function wall_dist ( packet , grid , celli , cellj , cellk , pos , dir ) !!function that returns distant to nearest wall and which wall that is (x ,y or z) use gridset_mod , only : cart_grid use photon_class , only : photon use vector_class , only : vector !> photon packet type ( photon ), intent ( inout ) :: packet type ( cart_grid ), intent ( in ) :: grid !> current position type ( vector ), intent ( inout ) :: pos !> which wall will we hit logical , intent ( inout ) :: dir (:) !> current voxel ID integer , intent ( inout ) :: celli , cellj , cellk real :: dx , dy , dz ! get distance to a wall in the x direction if ( packet % dir % x > 0. ) then dx = ( grid % xface ( celli + 1 ) - pos % x ) / packet % dir % x elseif ( packet % dir % x < 0. ) then dx = ( grid % xface ( celli ) - pos % x ) / packet % dir % x elseif ( packet % dir % x == 0. ) then dx = 10000 0. end if ! get distance to a wall in the y direction if ( packet % dir % y > 0. ) then dy = ( grid % yface ( cellj + 1 ) - pos % y ) / packet % dir % y elseif ( packet % dir % y < 0. ) then dy = ( grid % yface ( cellj ) - pos % y ) / packet % dir % y elseif ( packet % dir % y == 0. ) then dy = 10000 0. end if ! get distance to a wall in the z direction if ( packet % dir % z > 0. ) then dz = ( grid % zface ( cellk + 1 ) - pos % z ) / packet % dir % z elseif ( packet % dir % z < 0. ) then dz = ( grid % zface ( cellk ) - pos % z ) / packet % dir % z elseif ( packet % dir % z == 0. ) then dz = 10000 0. end if !get closest wall wall_dist = min ( dx , dy , dz ) if ( wall_dist < 0. ) print '(A,7F9.5)' , 'dcell < 0.0 warning! ' , wall_dist , dx , dy , dz , packet % dir if ( wall_dist == dx ) dir = ( / . TRUE ., . FALSE ., . FALSE . / ) if ( wall_dist == dy ) dir = ( / . FALSE ., . TRUE ., . FALSE . / ) if ( wall_dist == dz ) dir = ( / . FALSE ., . FALSE ., . TRUE . / ) if (. not . dir ( 1 ) . and . . not . dir ( 2 ) . and . . not . dir ( 3 )) print * , 'Error in dir flag' end function wall_dist subroutine update_pos ( packet , grid , pos , celli , cellj , cellk , dcell , wall_flag , dir ) !! routine that upates postions of photon and calls fresnel routines if photon leaves current voxel use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 use utils , only : str use vector_class , only : vector type ( photon ), intent ( in ) :: packet type ( vector ), intent ( inout ) :: pos type ( cart_grid ), intent ( in ) :: grid real , intent ( in ) :: dcell integer , intent ( inout ) :: celli , cellj , cellk logical , intent ( in ) :: wall_flag , dir (:) ! if we hit a wall if ( wall_flag ) then ! in the x direction if ( dir ( 1 )) then if ( packet % dir % x > 0. ) then pos % x = grid % xface ( celli + 1 ) + grid % delta elseif ( packet % dir % x < 0. ) then pos % x = grid % xface ( celli ) - grid % delta else print * , 'Error in x dir in update_pos' , dir , packet % dir end if pos % y = pos % y + packet % dir % y * dcell pos % z = pos % z + packet % dir % z * dcell ! y direction elseif ( dir ( 2 )) then pos % x = pos % x + packet % dir % x * dcell if ( packet % dir % y > 0. ) then pos % y = grid % yface ( cellj + 1 ) + grid % delta elseif ( packet % dir % y < 0. ) then pos % y = grid % yface ( cellj ) - grid % delta else print * , 'Error in y dir in update_pos' , dir , packet % dir end if pos % z = pos % z + packet % dir % z * dcell ! z direction elseif ( dir ( 3 )) then pos % x = pos % x + packet % dir % x * dcell pos % y = pos % y + packet % dir % y * dcell if ( packet % dir % z > 0. ) then pos % z = grid % zface ( cellk + 1 ) + grid % delta elseif ( packet % dir % z < 0. ) then pos % z = grid % zface ( cellk ) - grid % delta else print * , 'Error in z dir in update_pos' , dir , packet % dir end if else print * , 'Error in update_pos... ' // str ( dir ) error stop 1 end if else ! we dont hit a wall pos = pos + packet % dir * dcell end if if ( wall_flag ) then ! if we hit a wall, get current voxel call update_voxels ( pos , grid , celli , cellj , cellk ) end if end subroutine update_pos subroutine update_voxels ( pos , grid , celli , cellj , cellk ) !! updates the current voxel based upon position use gridset_mod , only : cart_grid use vector_class , only : vector type ( vector ), intent ( in ) :: pos type ( cart_grid ), intent ( in ) :: grid integer , intent ( inout ) :: celli , cellj , cellk celli = find ( pos % x , grid % xface ) cellj = find ( pos % y , grid % yface ) cellk = find ( pos % z , grid % zface ) end subroutine update_voxels integer function find ( val , a ) !! searches for bracketing indicies for a value val in an array a real , intent ( in ) :: val , a (:) integer :: n , lo , mid , hi n = size ( a ) lo = 0 hi = n + 1 if ( val == a ( 1 )) then find = 1 else if ( val == a ( n )) then find = n - 1 else if (( val > a ( n )) . or . ( val < a ( 1 ))) then find = - 1 else do if ( hi - lo <= 1 ) exit mid = ( hi + lo ) / 2 if ( val >= a ( mid )) then lo = mid else hi = mid end if end do find = lo end if end function find end module inttau2","tags":"","loc":"sourcefile/inttau2.f90.html"},{"title":"gridset.f90 – gridMCRT","text":"This file depends on sourcefile~~gridset.f90~~EfferentGraph sourcefile~gridset.f90 gridset.f90 sourcefile~iarray.f90 iarray.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~gridset.f90~~AfferentGraph sourcefile~gridset.f90 gridset.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~gridset.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~writer.f90->sourcefile~gridset.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules gridset_mod Source Code gridset.f90 Source Code module gridset_mod !! Module provides a cartesian grid type to store all grid related variables in a container !! Also provides a way of setting up the geomerty/grid for the simulation. use vector_class , only : vector implicit none private public :: gridset , cart_grid type :: cart_grid !> Size of grid in voxels in each direction integer :: nxg , nyg , nzg !> half size of grid in cm type ( vector ) :: dim !> Arrays that store the location of each grid cell(voxel) wall real , allocatable :: xface (:), yface (:), zface (:) !> ! Set small distance for use in optical depth integration routines for roundoff effects when crossing cell walls real :: delta end type cart_grid contains subroutine gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) !! Set up grids and create geometry use iarray , only : rhokap , rhokap use optical_properties_class , only : optical_properties !> cart_grid varible is assigned in this routine type ( cart_grid ), intent ( out ) :: grid type ( optical_properties ), intent ( in ) :: opt_prop integer , intent ( in ) :: nxg , nyg , nzg real , intent ( in ) :: xmax , ymax , zmax integer :: i , j , k real :: x , y , z , taueq1 , taupole1 , taueq2 , taupole2 print * , ' ' print * , 'Setting up grid....' ! set grid dimensions and voxel numbers grid % dim = vector ( xmax , ymax , zmax ) grid % nxg = nxg grid % nyg = nyg grid % nzg = nzg ! Set small distance for use in optical depth integration routines ! for roundoff effects when crossing cell walls grid % delta = 1.e-8 * ( 2. * grid % dim % z / grid % nzg ) ! allocate and set arrays to 0 call alloc_array ( grid ) call zarray ( grid ) ! setup grid cell walls do i = 1 , grid % nxg + 1 grid % xface ( i ) = ( i - 1 ) * 2. * grid % dim % x / grid % nxg end do do i = 1 , grid % nyg + 1 grid % yface ( i ) = ( i - 1 ) * 2. * grid % dim % y / grid % nyg end do do i = 1 , grid % nzg + 1 grid % zface ( i ) = ( i - 1 ) * 2. * grid % dim % z / grid % nzg end do !set up optical properties grid do i = 1 , grid % nxg x = grid % xface ( i ) - grid % dim % x + grid % dim % x / grid % nxg do j = 1 , grid % nyg y = grid % yface ( j ) - grid % dim % y + grid % dim % y / grid % nyg do k = 1 , grid % nzg z = grid % zface ( k ) - grid % dim % z + grid % dim % z / grid % nzg ! create a sphere of radius 1. if ( sqrt ( x ** 2 + y ** 2 + z ** 2 ) <= 1. ) then rhokap ( i , j , k ) = opt_prop % kappa else rhokap ( i , j , k ) = 0. end if end do end do end do ! Calculate equatorial and polar optical depths taueq1 = 0. taupole1 = 0. taueq2 = 0. taupole2 = 0. do i = 1 , grid % nxg taueq1 = taueq1 + rhokap ( i , grid % nyg / 2 , grid % nzg / 2 ) end do do i = 1 , grid % nzg taupole1 = taupole1 + rhokap ( grid % nxg / 2 , grid % nyg / 2 , i ) end do taueq1 = taueq1 * 2. * grid % dim % x / grid % nxg taupole1 = taupole1 * 2. * grid % dim % z / grid % nzg print '(A,F9.5,A,F9.5)' , ' taueq1 = ' , taueq1 , '  taupole1 = ' , taupole1 end subroutine gridset subroutine zarray ( grid ) !! set all 3D arrays to zero use iarray , only : rhokap type ( cart_grid ), intent ( inout ) :: grid rhokap = 0. grid % xface = 0. grid % yface = 0. grid % zface = 0. end subroutine zarray subroutine alloc_array ( grid ) !!  allocates allocatable 3D arrays use iarray , only : rhokap type ( cart_grid ), intent ( inout ) :: grid allocate ( rhokap ( grid % nxg , grid % nyg , grid % nzg )) allocate ( grid % xface ( grid % nxg + 1 )) allocate ( grid % yface ( grid % nyg + 1 )) allocate ( grid % zface ( grid % nzg + 1 )) end subroutine alloc_array end module gridset_mod","tags":"","loc":"sourcefile/gridset.f90.html"},{"title":"sourceph.f90 – gridMCRT","text":"This file depends on sourcefile~~sourceph.f90~~EfferentGraph sourcefile~sourceph.f90 sourceph.f90 sourcefile~constants.f90 constants.f90 sourcefile~sourceph.f90->sourcefile~constants.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 sourcefile~random_mod.f90 random_mod.f90 sourcefile~sourceph.f90->sourcefile~random_mod.f90 sourcefile~iarray.f90 iarray.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 sourcefile~photon_class.f90->sourcefile~constants.f90 sourcefile~photon_class.f90->sourcefile~random_mod.f90 sourcefile~photon_class.f90->sourcefile~optical_properties.f90 sourcefile~photon_class.f90->sourcefile~vector_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~sourceph.f90~~AfferentGraph sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules sourceph_mod Source Code sourceph.f90 Source Code module sourceph_mod !! Module contains the routines to inialise a photon, i.e different light sources. implicit none contains subroutine isotropic_point_src ( packet , grid ) !! set intial photon position use constants , only : TWOPI use gridset_mod , only : cart_grid use photon_class , only : photon use random_mod , only : ran2 !> photon object type ( photon ), intent ( out ) :: packet !> grid object type ( cart_grid ), intent ( in ) :: grid !set packet position packet % pos % z = 0.0 packet % pos % x = 0.0 packet % pos % y = 0.0 ! set packet cosines packet % phi = ran2 () * twoPI packet % cosp = cos ( packet % phi ) packet % sinp = sin ( packet % phi ) packet % cost = 2. * ran2 () - 1. packet % sint = sqrt ( 1. - packet % cost ** 2 ) ! set direction vector packet % dir % x = packet % sint * packet % cosp packet % dir % y = packet % sint * packet % sinp packet % dir % z = packet % cost ! set packet voxel packet % xcell = int ( grid % nxg * ( packet % pos % x + grid % dim % x ) / ( 2. * grid % dim % x )) + 1 packet % ycell = int ( grid % nyg * ( packet % pos % y + grid % dim % y ) / ( 2. * grid % dim % y )) + 1 packet % zcell = int ( grid % nzg * ( packet % pos % z + grid % dim % z ) / ( 2. * grid % dim % z )) + 1 packet % tflag = . false . end subroutine isotropic_point_src end module sourceph_mod","tags":"","loc":"sourcefile/sourceph.f90.html"},{"title":"utils.f90 – gridMCRT","text":"This file depends on sourcefile~~utils.f90~~EfferentGraph sourcefile~utils.f90 utils.f90 sourcefile~constants.f90 constants.f90 sourcefile~utils.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~utils.f90~~AfferentGraph sourcefile~utils.f90 utils.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~inttau2.f90->sourcefile~utils.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~utils.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules utils Source Code utils.f90 Source Code module utils !! module that contains utility functions and helper routines. implicit none !>functions to turn numerical variables into strings interface str module procedure str_I32 module procedure str_I64 module procedure str_Iarray module procedure str_R8 module procedure str_R8array module procedure str_logicalarray end interface str !>subroutines to swap numerical variables interface swap module procedure swap_I module procedure swap_R8 end interface swap !>change current directory interface function c_chdir ( path ) bind ( C , name = \"chdir\" ) use iso_c_binding character ( kind = c_char ), intent ( IN ) :: path ( * ) integer ( kind = C_int ) :: c_chdir end function c_chdir end interface private public :: str , swap , chdir , set_directories contains subroutine set_directories () !! define variables to hold paths to various folders use constants , only : cwd , homedir , fileplace , resdir !get current working directory call get_environment_variable ( 'PWD' , cwd ) ! get 'home' dir from cwd if ( index ( cwd , \"bin\" ) > 0 ) then ! if program is run from bin dir homedir = trim ( cwd ( 1 : len ( trim ( cwd )) - 3 )) else ! program is run from root dir homedir = trim ( cwd ) // \"/\" end if ! get data dir fileplace = trim ( homedir ) // 'data/' ! get res dir resdir = trim ( homedir ) // 'res/' end subroutine set_directories subroutine chdir ( path , error ) !! change current directory via c-lib call use iso_c_binding , only : c_null_char character ( * ), intent ( IN ) :: path integer , optional , intent ( OUT ) :: error integer :: err err = c_chdir ( trim ( path ) // c_null_char ) if ( present ( error )) error = err end subroutine chdir subroutine swap_I ( a , b ) !! swap two integer variables integer , intent ( INOUT ) :: a , b integer :: tmp tmp = a a = b b = tmp end subroutine swap_I subroutine swap_R8 ( a , b ) !! swap double precision variables double precision , intent ( INOUT ) :: a , b double precision :: tmp tmp = a a = b b = tmp end subroutine swap_R8 function str_I32 ( i ) !! convert an int32 integer into a string use iso_fortran_env , only : Int32 integer ( int32 ), intent ( IN ) :: i character ( len = :), allocatable :: str_I32 character ( len = 100 ) :: string write ( string , '(I100.1)' ) I str_I32 = trim ( adjustl ( string )) end function str_I32 function str_I64 ( i ) !! convert an int64 integer into a string use iso_fortran_env , only : Int64 integer ( Int64 ), intent ( IN ) :: i character ( len = :), allocatable :: str_I64 character ( len = 100 ) :: string write ( string , '(I100.1)' ) I str_I64 = trim ( adjustl ( string )) end function str_I64 function str_iarray ( i ) !! convert an int32 integer array into a string integer , intent ( IN ) :: i (:) character ( len = :), allocatable :: str_iarray character ( len = 100 ) :: string integer :: j do j = 1 , size ( i ) write ( string , '(I100.1)' ) I ( j ) str_iarray = str_iarray // ' ' // trim ( adjustl ( string )) end do end function str_iarray function str_R8 ( i ) !! convert an double precision float into a string double precision , intent ( IN ) :: i character ( len = :), allocatable :: str_R8 character ( len = 100 ) :: string write ( string , '(f100.16)' ) I str_R8 = trim ( adjustl ( string )) end function str_r8 function str_R8array ( a ) !! convert an double precision float array into a string double precision , intent ( IN ) :: a (:) character ( len = :), allocatable :: str_R8array character ( len = 100 ) :: string integer :: i do i = 1 , size ( a ) write ( string , '(f100.16)' ) a ( i ) str_R8array = str_R8array // ' ' // trim ( adjustl ( string )) end do end function str_R8array function str_logicalarray ( a ) !! convert an logical array into a string logical , intent ( IN ) :: a (:) character ( len = :), allocatable :: str_logicalarray character ( len = 100 ) :: string integer :: i do i = 1 , size ( a ) write ( string , '(L1)' ) a ( i ) str_logicalarray = str_logicalarray // ' ' // trim ( adjustl ( string )) end do end function str_logicalarray end module utils","tags":"","loc":"sourcefile/utils.f90.html"},{"title":"mcpolar.f90 – gridMCRT","text":"This file depends on sourcefile~~mcpolar.f90~~EfferentGraph sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~constants.f90 constants.f90 sourcefile~mcpolar.f90->sourcefile~constants.f90 sourcefile~gridset.f90 gridset.f90 sourcefile~mcpolar.f90->sourcefile~gridset.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~optical_properties.f90 optical_properties.f90 sourcefile~mcpolar.f90->sourcefile~optical_properties.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~random_mod.f90 random_mod.f90 sourcefile~mcpolar.f90->sourcefile~random_mod.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~utils.f90 utils.f90 sourcefile~mcpolar.f90->sourcefile~utils.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~gridset.f90->sourcefile~optical_properties.f90 sourcefile~iarray.f90 iarray.f90 sourcefile~gridset.f90->sourcefile~iarray.f90 sourcefile~vector_class.f90 vector_class.f90 sourcefile~gridset.f90->sourcefile~vector_class.f90 sourcefile~inttau2.f90->sourcefile~gridset.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~inttau2.f90->sourcefile~random_mod.f90 sourcefile~inttau2.f90->sourcefile~utils.f90 sourcefile~inttau2.f90->sourcefile~iarray.f90 sourcefile~inttau2.f90->sourcefile~vector_class.f90 sourcefile~photon_class.f90->sourcefile~constants.f90 sourcefile~photon_class.f90->sourcefile~optical_properties.f90 sourcefile~photon_class.f90->sourcefile~random_mod.f90 sourcefile~photon_class.f90->sourcefile~vector_class.f90 sourcefile~sourceph.f90->sourcefile~constants.f90 sourcefile~sourceph.f90->sourcefile~gridset.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 sourcefile~sourceph.f90->sourcefile~random_mod.f90 sourcefile~utils.f90->sourcefile~constants.f90 sourcefile~writer.f90->sourcefile~constants.f90 sourcefile~writer.f90->sourcefile~gridset.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Programs mcpolar Source Code mcpolar.f90 Source Code program mcpolar !imports use constants , only : resdir use gridset_mod , only : gridset , cart_grid use inttau2 , only : tauint1 use optical_properties_class , only : optical_properties , init_opt_sphere use photon_class , only : photon use random_mod , only : ran2 , init_seed use sourceph_mod , only : isotropic_point_src use utils , only : set_directories , str use writer_mod , only : writer implicit none !> variable that holds all information about the photon to be simulated type ( photon ) :: packet !> variable that holds the 3D grid information type ( cart_grid ) :: grid !> optical properties variable type ( optical_properties ) :: opt_prop !> number of photons to run in the simulation integer :: nphotons !> counter for number of scatterings for all photons double precision :: nscatt !> user defined seed integer :: seed !> temp variable or related to I/O from param file integer :: nxg , nyg , nzg , j , u real :: xmax , ymax , zmax , ran !> timing vars real :: start , finish call cpu_time ( start ) !set directory paths call set_directories () !set optical properties call init_opt_sphere ( opt_prop ) !set random seed seed = 42 call init_seed ( seed ) !**** Read in parameters from the file input.params open ( newunit = u , file = trim ( resdir ) // 'input.params' , status = 'old' ) read ( u , * ) nphotons read ( u , * ) xmax read ( u , * ) ymax read ( u , * ) zmax read ( u , * ) nxg read ( u , * ) nyg read ( u , * ) nzg close ( u ) print * , '' print * , '# of photons to run' , nphotons ! Set up grid call gridset ( grid , opt_prop , nxg , nyg , nzg , xmax , ymax , zmax ) ! inialise the number of scatterings counter nscatt = 0 print * , 'Photons now running' !loop over photons do j = 1 , nphotons !display progress if ( mod ( j , 10000 ) == 0 ) then print * , str ( j ) // ' scattered photons completed' end if ! Release photon from point source call isotropic_point_src ( packet , grid ) ! Find scattering location call tauint1 ( packet , grid ) ! Photon scatters in grid until it exits (tflag=TRUE) do while (. not . packet % tflag ) ran = ran2 () !interact with medium if ( ran < opt_prop % albedo ) then ! photon is scattered call packet % scatter ( opt_prop ) nscatt = nscatt + 1 else ! photon is absorbed packet % tflag = . true . exit end if ! Find next scattering location call tauint1 ( packet , grid ) end do end do ! end loop over nph photons print * , 'Average # of scatters per photon: ' // str ( nscatt / ( nphotons )) !write out files call writer ( grid , nphotons ) print * , 'write done' call cpu_time ( finish ) if ( finish - start >= 6 0. ) then print * , floor (( finish - start ) / 6 0. ) + mod ( finish - start , 6 0. ) / 10 0. else print * , 'time taken ~' // str ( floor ( finish - start / 6 0. )) // 's' end if end program mcpolar","tags":"","loc":"sourcefile/mcpolar.f90.html"},{"title":"constants.f90 – gridMCRT","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~mcpolar.f90 mcpolar.f90 sourcefile~mcpolar.f90->sourcefile~constants.f90 sourcefile~photon_class.f90 photon_class.f90 sourcefile~mcpolar.f90->sourcefile~photon_class.f90 sourcefile~sourceph.f90 sourceph.f90 sourcefile~mcpolar.f90->sourcefile~sourceph.f90 sourcefile~utils.f90 utils.f90 sourcefile~mcpolar.f90->sourcefile~utils.f90 sourcefile~writer.f90 writer.f90 sourcefile~mcpolar.f90->sourcefile~writer.f90 sourcefile~inttau2.f90 inttau2.f90 sourcefile~mcpolar.f90->sourcefile~inttau2.f90 sourcefile~photon_class.f90->sourcefile~constants.f90 sourcefile~sourceph.f90->sourcefile~constants.f90 sourcefile~sourceph.f90->sourcefile~photon_class.f90 sourcefile~utils.f90->sourcefile~constants.f90 sourcefile~writer.f90->sourcefile~constants.f90 sourcefile~inttau2.f90->sourcefile~photon_class.f90 sourcefile~inttau2.f90->sourcefile~utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules constants Source Code constants.f90 Source Code module constants !! Constants used throughout the simulation. implicit none !> mathematical constants real , parameter :: PI = 4. * atan ( 1. ), TWOPI = 2. * PI !> variables that store directories for files etc character ( len = 255 ) :: cwd , homedir , fileplace , resdir end module constants","tags":"","loc":"sourcefile/constants.f90.html"}]}